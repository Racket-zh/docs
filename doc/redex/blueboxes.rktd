15253
((3) 0 () 11 ((q lib "redex/pict.rkt") (q lib "redex/reduction-semantics.rkt") (q 11716 . 6) (q lib "redex/gui.rkt") (q lib "redex/benchmark.rkt") (q 41343 . 20) (q 17342 . 5) (q 1576 . 5) (q 43631 . 5) (q 44128 . 3) (q 17477 . 5)) () (h ! (equal) ((c form c (c (? . 0) q relation->pict)) q (30980 . 2)) ((c form c (c (? . 0) q with-compound-rewriter)) q (41064 . 4)) ((c def c (c (? . 1) q reduction-relation->rule-names)) q (6969 . 3)) ((c form c (c (? . 1) q with)) q (8288 . 2)) ((c form c (c (? . 1) q term)) q (1970 . 3)) ((c def c (c (? . 0) q curly-quotes-for-strings)) q (38293 . 4)) ((c def c (c (? . 3) q traces)) q (19159 . 45)) ((c def c (c (? . 0) q default-font-size)) q (37629 . 4)) ((c def c (c (? . 0) q metafunction-line-gap-space)) q (39384 . 4)) ((c form c (c (? . 1) q check-metafunction)) q (18157 . 15)) ((c def c (c (? . 1) q plug)) q (2571 . 4)) ((c form c (c (? . 1) q I)) q (11899 . 2)) ((c def c (c (? . 1) q exn:fail:redex:generation-failure?)) q (19082 . 3)) ((c def c (c (? . 1) q relation-coverage)) q (13968 . 4)) ((c def c (c (? . 1) q make-counterexample)) c (? . 6)) ((c def c (c (? . 0) q reduction-relation-rule-extra-separation)) q (37951 . 5)) ((c def c (c (? . 1) q bind?)) c (? . 7)) ((c def c (c (? . 0) q render-lw)) q (42356 . 4)) ((c def c (c (? . 1) q reduction-relation?)) q (7193 . 3)) ((c def c (c (? . 1) q make-immutable-binding-hash)) q (4396 . 4)) ((c def c (c (? . 0) q grammar-style)) q (36314 . 4)) ((c form c (c (? . 1) q redex-check)) q (15868 . 29)) ((c form c (c (? . 1) q define-term)) q (2409 . 2)) ((c def c (c (? . 1) q struct:exn:fail:redex:test)) c (? . 10)) ((c def c (c (? . 1) q derivation?)) c (? . 2)) ((c form c (c (? . 1) q define-union-language)) q (4267 . 5)) ((c def c (c (? . 0) q metafunction-combine-contract-and-rules)) q (39644 . 5)) ((c def c (c (? . 1) q judgment-form?)) q (12211 . 3)) ((c form c (c (? . 1) q define-metafunction)) q (8300 . 33)) ((c def c (c (? . 1) q redex-pseudo-random-generator)) q (18913 . 4)) ((c def c (c (? . 1) q derivation-term)) c (? . 2)) ((c def c (c (? . 0) q just-before)) q (42607 . 4)) ((c def c (c (? . 0) q metafunction-cases)) q (34888 . 11)) ((c form c (c (? . 1) q -->)) q (8264 . 2)) ((c form c (c (? . 1) q define-extended-language)) q (3842 . 11)) ((c def c (c (? . 4) q run-results)) c (? . 8)) ((c def c (c (? . 0) q render-reduction-relation)) q (29731 . 8)) ((c form c (c (? . 0) q render-metafunction)) q (30209 . 3)) ((c def c (c (? . 3) q show-derivations)) q (24542 . 11)) ((c def c (c (? . 1) q default-language)) q (4784 . 4)) ((c def c (c (? . 0) q current-render-pict-adjust)) q (40525 . 4)) ((c form c (c (? . 1) q nothing)) q (3827 . 2)) ((c form c (c (? . 4) q define-rewrite)) q (42958 . 6)) ((c def c (c (? . 0) q rule-pict-info-label)) q (32626 . 3)) ((c def c (c (? . 0) q where-combine)) q (40360 . 4)) ((c def c (c (? . 1) q default-attempt-size)) q (18694 . 3)) ((c def c (c (? . 1) q match-bindings)) q (1511 . 3)) ((c def c (c (? . 1) q language-nts)) q (4648 . 3)) ((c def c (c (? . 0) q lw-metafunction?)) c (? . 5)) ((c form c (c (? . 1) q build-derivations)) q (11667 . 2)) ((c def c (c (? . 1) q default-check-attempts)) q (18776 . 4)) ((c form c (c (? . 1) q test-->>∃)) q (13208 . 10)) ((c def c (c (? . 0) q fill-between)) q (42810 . 5)) ((c def c (c (? . 4) q struct:bmark-log-data)) c (? . 9)) ((c def c (c (? . 0) q render-language)) q (29293 . 6)) ((c def c (c (? . 3) q term-node-set-position!)) q (26367 . 5)) ((c def c (c (? . 3) q light-pen-color)) q (27504 . 4)) ((c def c (c (? . 0) q rule-pict-info?)) q (32282 . 3)) ((c def c (c (? . 0) q rule-pict-info-arrow)) q (32340 . 3)) ((c def c (c (? . 0) q lw-column-span)) c (? . 5)) ((c form c (c (? . 0) q render-relation)) q (30780 . 2)) ((c form c (c (? . 1) q test-judgment-holds)) q (13561 . 2)) ((c def c (c (? . 0) q label-style)) q (36213 . 4)) ((c def c (c (? . 0) q relation-clauses-combine)) q (39840 . 5)) ((c form c (c (? . 0) q judgment-form->pict)) q (31019 . 2)) ((c def c (c (? . 3) q term-node-children)) q (25732 . 3)) ((c form c (c (? . 0) q metafunction->pict)) q (30663 . 2)) ((c def c (c (? . 0) q set-lw-metafunction?!)) c (? . 5)) ((c form c (c (? . 4) q define-rewrite/compose)) q (43113 . 2)) ((c def c (c (? . 3) q initial-char-width)) q (27025 . 4)) ((c def c (c (? . 0) q struct:lw)) c (? . 5)) ((c def c (c (? . 0) q rule-pict-info-computed-label)) q (32736 . 4)) ((c def c (c (? . 0) q lw->pict)) q (42482 . 4)) ((c def c (c (? . 1) q counterexample-term)) c (? . 6)) ((c def c (c (? . 0) q set-lw-unq?!)) c (? . 5)) ((c def c (c (? . 1) q bind-name)) c (? . 7)) ((c def c (c (? . 0) q reduction-relation->pict)) q (30054 . 4)) ((c def c (c (? . 3) q term-node-expr)) q (26308 . 3)) ((c def c (c (? . 0) q rule-pict-info-lhs)) q (32438 . 3)) ((c def c (c (? . 0) q set-lw-line!)) c (? . 5)) ((c def c (c (? . 1) q apply-reduction-relation*)) q (7617 . 12)) ((c def c (c (? . 0) q lw-unq?)) c (? . 5)) ((c form c (c (? . 1) q redex-match?)) q (1386 . 3)) ((c def c (c (? . 0) q reduction-relation-rule-separation)) q (37792 . 4)) ((c def c (c (? . 3) q term-node-set-color!)) q (25983 . 4)) ((c def c (c (? . 1) q set-cache-size!)) q (1792 . 3)) ((c def c (c (? . 4) q run-results-time)) c (? . 8)) ((c def c (c (? . 0) q extend-language-show-extended-order)) q (31465 . 4)) ((c def c (c (? . 0) q term->pict/pretty-write)) q (28984 . 8)) ((c form c (c (? . 1) q fresh)) q (8275 . 2)) ((c def c (c (? . 3) q dark-brush-color)) q (27345 . 4)) ((c def c (c (? . 1) q variables-not-in)) q (2750 . 4)) ((c form c (c (? . 1) q hole)) q (2020 . 2)) ((c def c (c (? . 0) q lw-column)) c (? . 5)) ((c def c (c (? . 0) q metafunction-fill-acceptable-width)) q (39511 . 4)) ((c def c (c (? . 0) q lw-line)) c (? . 5)) ((c form c (c (? . 1) q compatible-closure)) q (7065 . 2)) ((c def c (c (? . 1) q counterexample)) c (? . 6)) ((c def c (c (? . 0) q lw)) c (? . 5)) ((c def c (c (? . 1) q IO-judgment-form?)) q (12268 . 3)) ((c def c (c (? . 3) q light-brush-color)) q (27661 . 4)) ((c def c (c (? . 0) q render-reduction-relation-rules)) q (31616 . 11)) ((c def c (c (? . 4) q bmark-log-data)) c (? . 9)) ((c def c (c (? . 3) q stepper)) q (23952 . 7)) ((c def c (c (? . 1) q current-traced-metafunctions)) q (12328 . 4)) ((c def c (c (? . 4) q bmark-log-directory)) q (44294 . 6)) ((c def c (c (? . 0) q set-lw-column!)) c (? . 5)) ((c form c (c (? . 1) q redex-let)) q (2266 . 2)) ((c def c (c (? . 0) q rule-pict-style)) q (32112 . 4)) ((c def c (c (? . 3) q traces/ps)) q (21530 . 45)) ((c def c (c (? . 1) q check-redundancy)) q (1865 . 4)) ((c def c (c (? . 0) q set-lw-e!)) c (? . 5)) ((c def c (c (? . 1) q struct:bind)) c (? . 7)) ((q def ((lib "redex/benchmark/models/all-info.rkt") all-mods)) q (44531 . 3)) ((c def c (c (? . 0) q set-lw-column-span!)) c (? . 5)) ((c def c (c (? . 1) q match?)) q (1458 . 3)) ((c def c (c (? . 0) q build-lw)) q (41928 . 10)) ((c form c (c (? . 0) q render-judgment-form)) q (30870 . 2)) ((c def c (c (? . 1) q derivation-name)) c (? . 2)) ((c def c (c (? . 4) q run-results-cexps)) c (? . 8)) ((c form c (c (? . 1) q reduction-relation)) q (5181 . 43)) ((c def c (c (? . 0) q reduction-relation-rule-line-separation)) q (38123 . 5)) ((c def c (c (? . 3) q default-pretty-printer)) q (28279 . 6)) ((c form c (c (? . 0) q with-atomic-rewriters)) q (40918 . 3)) ((c form c (c (? . 1) q check-reduction-relation)) q (17648 . 15)) ((c def c (c (? . 0) q to-lw/stx)) q (42303 . 3)) ((c form c (c (? . 1) q define-metafunction/extension)) q (9614 . 5)) ((c form c (c (? . 0) q render-metafunctions)) q (30340 . 10)) ((c def c (c (? . 3) q term-node-labels)) q (25891 . 3)) ((c def c (c (? . 4) q run-gen-and-check/mods)) q (43770 . 9)) ((c def c (c (? . 3) q term-node-color)) q (26115 . 3)) ((c def c (c (? . 0) q arrow->pict)) q (38571 . 3)) ((c def c (c (? . 3) q stepper/seed)) q (24228 . 7)) ((c form c (c (? . 1) q test-predicate)) q (13634 . 2)) ((c def c (c (? . 0) q lw-line-span)) c (? . 5)) ((c def c (c (? . 1) q exn:fail:redex:test)) c (? . 10)) ((c def c (c (? . 3) q reduction-steps-cutoff)) q (26809 . 4)) ((c def c (c (? . 1) q bind-exp)) c (? . 7)) ((c def c (c (? . 0) q metafunction-style)) q (36625 . 4)) ((c def c (c (? . 1) q variable-not-in)) q (2662 . 4)) ((c def c (c (? . 0) q homemade-white-square-bracket)) q (34449 . 3)) ((c form c (c (? . 1) q in-domain?)) q (9756 . 2)) ((c def c (c (? . 1) q apply-reduction-relation/tag-with-names)) q (7389 . 6)) ((c form c (c (? . 1) q test-equal)) q (12531 . 7)) ((c form c (c (? . 1) q test-->)) q (12957 . 9)) ((c def c (c (? . 0) q linebreaks)) q (34608 . 4)) ((c form c (c (? . 0) q term->pict)) q (28522 . 2)) ((c def c (c (? . 0) q rule-pict-info-rhs)) q (32532 . 3)) ((c form c (c (? . 1) q substitute)) q (5132 . 2)) ((c form c (c (? . 1) q define-extended-judgment-form)) q (11327 . 6)) ((c form c (c (? . 1) q term-match)) q (2448 . 2)) ((c form c (c (? . 1) q test-->>E)) q (13544 . 2)) ((c def c (c (? . 3) q pretty-print-parameters)) q (28138 . 4)) ((c form c (c (? . 1) q redex-match)) q (1310 . 3)) ((c def c (c (? . 0) q metafunction-up/down-indent)) q (34018 . 4)) ((c def c (c (? . 0) q set-lw-line-span!)) c (? . 5)) ((c def c (c (? . 1) q exn:fail:redex:test?)) c (? . 10)) ((c form c (c (? . 1) q context-closure)) q (7133 . 2)) ((c def c (c (? . 1) q depth-dependent-order?)) q (16950 . 5)) ((c def c (c (? . 0) q extend-language-show-union)) q (31342 . 4)) ((c def c (c (? . 0) q make-lw)) c (? . 5)) ((c def c (c (? . 0) q where-make-prefix-pict)) q (40197 . 4)) ((c def c (c (? . 1) q make-derivation)) c (? . 2)) ((c form c (c (? . 0) q to-lw)) q (42283 . 2)) ((c def c (c (? . 1) q coverage?)) q (13916 . 3)) ((c def c (c (? . 1) q alpha-equivalent?)) q (4931 . 8)) ((c form c (c (? . 1) q extend-reduction-relation)) q (6795 . 2)) ((c def c (c (? . 3) q light-text-color)) q (27979 . 4)) ((c form c (c (? . 1) q judgment-holds)) q (11459 . 6)) ((c form c (c (? . 1) q in-hole)) q (2032 . 2)) ((c def c (c (? . 1) q exn:fail:redex:test-source)) c (? . 10)) ((c def c (c (? . 1) q current-cache-all?)) q (8147 . 4)) ((c form c (c (? . 0) q with-compound-rewriters)) q (41221 . 3)) ((c def c (c (? . 1) q test-results)) q (13665 . 2)) ((c form c (c (? . 1) q shadow)) q (3813 . 2)) ((c def c (c (? . 0) q set-arrow-pict!)) q (38632 . 4)) ((c def c (c (? . 0) q render-term/pretty-write)) q (28554 . 10)) ((c def c (c (? . 1) q make-exn:fail:redex:test)) c (? . 10)) ((c def c (c (? . 3) q derivation/ps)) q (25121 . 13)) ((c form c (c (? . 1) q define-relation)) q (11917 . 10)) ((c def c (c (? . 3) q term-node?)) q (26756 . 3)) ((c def c (c (? . 3) q term-node-parents)) q (25812 . 3)) ((c def c (c (? . 1) q make-binding-hash)) q (4527 . 4)) ((c def c (c (? . 1) q make-bind)) c (? . 7)) ((c form c (c (? . 1) q define-judgment-form)) q (9808 . 51)) ((c form c (c (? . 0) q metafunctions->pict)) q (30727 . 2)) ((c def c (c (? . 1) q covered-cases)) q (14099 . 3)) ((c def c (c (? . 1) q apply-reduction-relation)) q (7255 . 4)) ((c form c (c (? . 0) q with-atomic-rewriter)) q (40745 . 4)) ((c form c (c (? . 1) q test-->>)) q (12660 . 11)) ((c def c (c (? . 1) q bind)) c (? . 7)) ((c def c (c (? . 1) q counterexample?)) c (? . 6)) ((c def c (c (? . 1) q compiled-lang?)) q (4727 . 3)) ((c def c (c (? . 0) q non-terminal-style)) q (36740 . 4)) ((c def c (c (? . 4) q bmark-log-data-data)) c (? . 9)) ((c def c (c (? . 0) q just-after)) q (42709 . 4)) ((c def c (c (? . 3) q dark-text-color)) q (27822 . 4)) ((c form c (c (? . 1) q redex-generator)) q (17132 . 7)) ((c def c (c (? . 0) q paren-style)) q (36419 . 4)) ((c def c (c (? . 4) q run-results-tries)) c (? . 8)) ((c form c (c (? . 0) q with-unquote-rewriter)) q (40696 . 2)) ((c def c (c (? . 0) q render-language-nts)) q (31068 . 4)) ((c def c (c (? . 0) q white-square-bracket)) q (34272 . 4)) ((c form c (c (? . 1) q redex-index)) q (15822 . 2)) ((c def c (c (? . 0) q metafunction-pict-style)) q (33282 . 17)) ((c def c (c (? . 0) q reduction-rule-style/c)) q (32241 . 2)) ((c def c (c (? . 0) q non-terminal-superscript-style)) q (36990 . 4)) ((c form c (c (? . 1) q term-let)) q (2063 . 8)) ((c form c (c (? . 1) q define-language)) q (2913 . 23)) ((c def c (c (? . 4) q run-results?)) c (? . 8)) ((c form c (c (? . 1) q O)) q (11908 . 2)) ((c def c (c (? . 4) q bmark-log-data?)) c (? . 9)) ((c form c (c (? . 1) q redex-enum)) q (15783 . 2)) ((c def c (c (? . 0) q horizontal-bar-spacing)) q (38958 . 5)) ((c def c (c (? . 0) q non-terminal-subscript-style)) q (36855 . 4)) ((c def c (c (? . 1) q default-equiv)) q (13698 . 4)) ((c form c (c (? . 4) q include/rewrite)) q (43161 . 2)) ((c def c (c (? . 0) q language->pict)) q (29550 . 5)) ((c def c (c (? . 0) q current-text)) q (38408 . 4)) ((c def c (c (? . 0) q default-white-square-bracket)) q (34529 . 3)) ((c def c (c (? . 4) q benchmark-logging-to)) q (44185 . 4)) ((c def c (c (? . 0) q metafunction-gap-space)) q (39140 . 4)) ((c def c (c (? . 1) q exn:fail:redex?)) q (2855 . 3)) ((c form c (c (? . 1) q redex-let*)) q (2337 . 2)) ((c form c (c (? . 0) q render-term)) q (28457 . 3)) ((c def c (c (? . 0) q label-font-size)) q (37234 . 4)) ((c def c (c (? . 1) q derivation)) c (? . 2)) ((c def c (c (? . 3) q term-node-height)) q (26693 . 3)) ((c def c (c (? . 4) q struct:run-results)) c (? . 8)) ((c def c (c (? . 0) q sc-linebreaks)) q (34745 . 4)) ((c def c (c (? . 1) q struct:derivation)) c (? . 2)) ((c def c (c (? . 0) q rule-pict-info->side-condition-pict)) q (32854 . 5)) ((c def c (c (? . 3) q term-node-set-red!)) q (26215 . 4)) ((c def c (c (? . 0) q lw?)) c (? . 5)) ((c def c (c (? . 1) q caching-enabled?)) q (1693 . 4)) ((c def c (c (? . 0) q arrow-space)) q (33064 . 4)) ((c def c (c (? . 1) q exn:fail:redex:test-term)) c (? . 10)) ((c form c (c (? . 1) q generate-term)) q (14196 . 35)) ((c def c (c (? . 0) q judgment-form-show-rule-names)) q (36062 . 4)) ((c def c (c (? . 1) q derivation-subs)) c (? . 2)) ((c form c (c (? . 1) q make-coverage)) q (13829 . 5)) ((c def c (c (? . 3) q initial-font-size)) q (26924 . 4)) ((c form c (c (? . 1) q ::=)) q (3802 . 2)) ((c form c (c (? . 1) q mf-apply)) q (2047 . 2)) ((c def c (c (? . 1) q struct:counterexample)) c (? . 6)) ((c def c (c (? . 0) q non-terminal-gap-space)) q (31225 . 4)) ((c def c (c (? . 0) q judgment-form-cases)) q (35500 . 11)) ((c def c (c (? . 0) q delimit-ellipsis-arguments?)) q (34147 . 4)) ((c def c (c (? . 0) q label-space)) q (33173 . 4)) ((c form c (c (? . 1) q term-match/single)) q (2506 . 2)) ((c def c (c (? . 0) q metafunction-font-size)) q (37393 . 6)) ((c def c (c (? . 3) q term-node-y)) q (26573 . 3)) ((c def c (c (? . 0) q lw-e)) c (? . 5)) ((c def c (c (? . 0) q metafunction-rule-gap-space)) q (39257 . 4)) ((c def c (c (? . 0) q metafunction-arrow-pict)) q (40034 . 4)) ((c def c (c (? . 3) q term-node-x)) q (26515 . 3)) ((c def c (c (? . 0) q white-bracket-sizing)) q (38728 . 5)) ((c def c (c (? . 3) q term-node-width)) q (26631 . 3)) ((c def c (c (? . 3) q dark-pen-color)) q (27190 . 4)) ((c def c (c (? . 1) q union-reduction-relations)) q (6871 . 3)) ((c def c (c (? . 4) q run-gen-and-check)) q (43217 . 11)) ((c def c (c (? . 0) q literal-style)) q (36520 . 4)) ((c def c (c (? . 0) q default-style)) q (37129 . 4))))

Goals
— abstract syntax
— notions of reduction, substitution
— reductions and calculations
— semantics
— standard reduction
— abstract register machines
— types

Goals
— Redex versus Racket
— define languages
— develop metafunctions, includes basic testing, submodules
— extend languages
— generalizing with any

Goals
— developing meta-functions
— discovering Redex patterns

Goals
— extend languages with concepts needed for reduction relations
— developing reduction relations
— defining a semantics
— testing against a language

Goals
— developing reductions
— semantics

Goals
— typed languages
— developing type judgments
— subject reduction

Goals
— subject reduction testing with trace
— typing judgments

Goals
— revise the language for assignment statements
— a standard reduction system for expression-store tuples
— revise the language for raising exceptions
— a general reduction system for exceptions

Goals
— develop a general reduction system for Lambda with assignments
— develop a standard reduction system for Lambda with exceptions

Goals
— why these three machines: CC machine, CK machine, CEK machine
— theorems connecting the machines, theorems for debugging
— equivalence theorems

Goals
— develop the CESK machine
语法
(redex-match lang pattern term-expr)
(redex-match lang pattern)
语法
(redex-match? lang pattern any)
(redex-match? lang pattern)
函数
(match? val) -> boolean?
  val : any/c
函数
(match-bindings m) -> (listof bind?)
  m : match?
struct
(struct bind (name exp)
    #:extra-constructor-name make-bind)
  name : symbol?
  exp : any/c
parameter
(caching-enabled?) -> boolean?
(caching-enabled? on?) -> void?
  on? : boolean?
函数
(set-cache-size! size) -> void?
  size : positive-integer?
parameter
(check-redundancy) -> boolean?
(check-redundancy check?) -> void?
  check? : boolean?
语法
(term term)
(term term #:lang lang-id)
语法
hole
语法
in-hole
语法
mf-apply
语法
(term-let ([tl-pat expr] ...) body)
 
    tl-pat = identifier
           | (tl-pat-ele ...)
              
tl-pat-ele = tl-pat
           | tl-pat ... ; a literal ellipsis
语法
(redex-let language ([pattern expression] ...) body ...+)
语法
(redex-let* language ([pattern expression] ...) body ...+)
语法
(define-term identifier term)
语法
(term-match language [pattern expression] ...)
语法
(term-match/single language [pattern expression] ...)
函数
(plug context expression) -> any
  context : any/c
  expression : any/c
函数
(variable-not-in t prefix) -> symbol?
  t : any/c
  prefix : symbol?
函数
(variables-not-in t vars) -> (listof symbol?)
  t : any/c
  vars : (listof symbol?)
函数
(exn:fail:redex? v) -> boolean?
  v : any/c
语法
(define-language lang-name
  non-terminal-def ...
  maybe-binding-spec)
 
  non-terminal-def = (non-terminal-name ...+ ::= pattern ...+)
                   | (non-terminal-name pattern ...+)
                   | ((non-terminal-name ...+) pattern ...+)
                      
maybe-binding-spec = 
                   | #:binding-forms binding-pattern ...
                      
   binding-pattern = pattern
                   | binding-pattern #:exports beta
                   | binding-pattern #:refers-to beta
                   | binding-pattern #:...bind (id beta beta)
                      
              beta = nothing
                   | symbol
                   | (shadow beta-sequence ...)
                      
     beta-sequence = beta
                   | ... ; literal ellipsis
语法
::=
语法
shadow
语法
nothing
语法
(define-extended-language extended-lang base-lang
  non-terminal-def ...
  maybe-binding-spec)
 
  non-terminal-def = (non-terminal-name ...+ ::= pattern ...+)
                   | (non-terminal-name pattern ...+)
                   | ((non-terminal-name ...+) pattern ...+)
                      
maybe-binding-spec = 
                   | #:binding-forms binding-declaration ...
语法
(define-union-language L base/prefix-lang ...)
 
base/prefix-lang = lang-id
                 | (prefix lang-id)
函数
(make-immutable-binding-hash lang [assocs]) -> dict?
  lang : compiled-lang?
  assocs : (listof pair?) = '()
函数
(make-binding-hash lang [assocs]) -> dict?
  lang : compiled-lang?
  assocs : (listof pair?) = '()
函数
(language-nts lang) -> (listof symbol?)
  lang : compiled-lang?
函数
(compiled-lang? l) -> boolean?
  l : any/c
parameter
(default-language) -> (or/c false/c compiled-lang?)
(default-language lang) -> void?
  lang : (or/c false/c compiled-lang?)
函数
(alpha-equivalent? lang lhs rhs) -> boolean?
  lang : compiled-lang?
  lhs : any/c
  rhs : any/c
(alpha-equivalent? lhs rhs) -> boolean?
  lhs : any/c
  rhs : any/c
metafunction
(substitute val old-var new-val)
语法
(reduction-relation language domain codomain base-arrow
                    reduction-case ...
                    shortcuts)
 
        domain = 
               | #:domain pattern
                  
      codomain = 
               | #:codomain pattern
                  
    base-arrow = 
               | #:arrow base-arrow-name
                  
reduction-case = (arrow-name pattern term red-extras ...)
                  
    red-extras = rule-name
               | (fresh fresh-clause ...)
               | (side-condition racket-expression)
               | (where pattern term)
               | (where/hidden pattern term)
               | (where/error pattern term)
               | (bind pattern term)
               | (bind/hidden pattern term)
               | (judgment-holds (judgment-form-id pat/term ...))
               | (judgment-holds (relation-id term ...))
               | (side-condition/hidden racket-expression)
                  
     shortcuts = 
               | with shortcut ...
                  
      shortcut = [(old-arrow-name pattern term)
                  (new-arrow-name identifier identifier)]
                  
     rule-name = identifier
               | string
               | (computed-name racket-expression)
                  
  fresh-clause = var
               | ((var1 ...) (var2 ...))
                  
      pat/term = pattern
               | term
语法
(extend-reduction-relation reduction-relation language more ...)
函数
(union-reduction-relations r ...) -> reduction-relation?
  r : reduction-relation?
函数
(reduction-relation->rule-names r) -> (listof symbol?)
  r : reduction-relation?
语法
(compatible-closure reduction-relation lang non-terminal)
语法
(context-closure reduction-relation lang pattern)
函数
(reduction-relation? v) -> boolean?
  v : any/c
函数
(apply-reduction-relation r t) -> (listof any/c)
  r : (or/c reduction-relation? IO-judgment-form?)
  t : any/c
函数
(apply-reduction-relation/tag-with-names r  
                                         t) 
 -> (listof (list/c (or/c #f string?) any/c))
  r : (or/c reduction-relation? IO-judgment-form?)
  t : any/c
函数
(apply-reduction-relation*  r                       
                            t                       
                           [#:all? all              
                            #:cache-all? cache-all? 
                            #:stop-when stop-when]) 
 -> (listof any/c)
  r : (or/c reduction-relation? IO-judgment-form?)
  t : any/c
  all : boolean? = #f
  cache-all? : boolean? = (or all? (current-cache-all?))
  stop-when : (-> any/c any) = (λ (x) #f)
parameter
(current-cache-all?) -> boolean?
(current-cache-all? cache-all?) -> void?
  cache-all? : boolean?
语法
-->
语法
fresh
语法
with
语法
(define-metafunction language
  metafunction-contract
  [(name pattern ...) term metafunction-extras ...]
  ...)
 
metafunction-contract = 
                      | id : pattern-sequence ... -> range
                        maybe-pre-condition
                        maybe-post-condition
                         
  maybe-pre-condition = #:pre term
                      | 
                         
 maybe-post-condition = #:post term
                      | 
                         
                range = pattern
                      | pattern or range
                      | pattern ∨ range
                      | pattern ∪ range
                         
  metafunction-extras = (side-condition racket-expression)
                      | (side-condition/hidden racket-expression)
                      | (where pat term)
                      | (where/hidden pat term)
                      | (where/error pat term)
                      | (judgment-holds
                         (judgment-form-id pat/term ...))
                      | (judgment-holds
                         (relation-id term ...))
                      | (clause-name name)
                      | or term
语法
(define-metafunction/extension f language
  metafunction-contract
  [(g pattern ...) term metafunction-extras ...]
  ...)
语法
(in-domain? (metafunction-name term ...))
语法
(define-judgment-form language
  mode-spec
  contract-spec
  invariant-spec
  rule rule ...)
 
     mode-spec = #:mode (form-id pos-use ...)
                  
 contract-spec = 
               | #:contract (form-id pattern-sequence ...)
                  
invariant-spec = #:inv term
               | 
                  
       pos-use = I
               | O
                  
          rule = [premise
                  ...
                  dashes rule-name
                  conclusion]
               | [conclusion
                  premise
                  ...
                  rule-name]
                  
    conclusion = (form-id pat/term ...)
                  
       premise = (judgment-form-id pat/term ...) maybe-ellipsis
               | (relation-id pat/term ...) maybe-ellipsis
               | (where pattern term)
               | (where/hidden pattern term)
               | (where/error pattern term)
               | (side-condition term)
               | (side-condition/hidden term)
                  
     rule-name = 
               | string
               | non-ellipsis-non-dashes-var
                  
      pat/term = pattern
               | term
                  
maybe-ellipsis = 
               | ...
                  
        dashes = ---
               | ----
               | -----
               | etc.
语法
(define-extended-judgment-form language judgment-form-id
  mode-spec
  contract-spec
  invariant-spec
  rule ...)
语法
(judgment-holds judgment-or-relation)
(judgment-holds judgment-or-relation term)
 
judgment-or-relation = (judgment-form-id pat/term ...)
                     | (relation-id pat/term ...)
语法
(build-derivations judgment-or-relation)
struct
(struct derivation (term name subs)
    #:extra-constructor-name make-derivation)
  term : any/c
  name : (or/c string? #f)
  subs : (listof derivation?)
语法
I
语法
O
语法
(define-relation language
  relation-contract
  [(name pattern ...)
   term ...
   metafunction-extras ...] ...)
 
relation-contract = 
                  | form-id ⊂ pattern x ... x pattern
                  | form-id ⊆ pattern × ... × pattern
函数
(judgment-form? v) -> boolean?
  v : any/c
函数
(IO-judgment-form? v) -> boolean?
  v : any/c
parameter
(current-traced-metafunctions) -> (or/c 'all (listof symbol?))
(current-traced-metafunctions traced-metafunctions) -> void?
  traced-metafunctions : (or/c 'all (listof symbol?))
语法
(test-equal e1 e2 option)
 
option = #:equiv pred-expr
       | 
 
  pred-expr : (-> any/c any/c any/c)
语法
(test-->> rel-expr option ... e1-expr e2-expr ...)
 
option = #:cycles-ok
       | #:equiv pred-expr
       | #:pred pred-expr
 
  rel-expr : (or/c reduction-relation? IO-judgment-form?)
  pred-expr : (-> any/c any)
  e1-expr : any/c
  e2-expr : any/c
语法
(test--> rel-expr option ... e1-expr e2-expr ...)
 
option = #:equiv pred-expr
 
  rel-expr : (or/c reduction-relation? IO-judgment-form?)
  pred-expr : (-> any/c any/c any/c)
  e1-expr : any/c
  e2-expr : any/c
语法
(test-->>∃ option ... rel-expr start-expr goal-expr)
 
option = #:steps steps-expr
 
  rel-expr : (or/c reduction-relation? IO-judgment-form?)
  start-expr : any/c
  goal-expr : (or/c (-> any/c any/c)
                    (not/c procedure?))
  steps-expr : (or/c natural-number/c +inf.0)
语法
test-->>E
语法
(test-judgment-holds (judgment-form-or-relation pat/term ...))
语法
(test-predicate p? e)
函数
(test-results) -> void?
parameter
(default-equiv) -> (-> any/c any/c any/c)
(default-equiv equiv) -> void?
  equiv : (-> any/c any/c any/c)
语法
(make-coverage subject)
 
subject = metafunction
        | relation-expr
函数
(coverage? v) -> boolean?
  v : any/c
parameter
(relation-coverage) -> (listof coverage?)
(relation-coverage tracked) -> void?
  tracked : (listof coverage?)
函数
(covered-cases c) -> (listof (cons/c string? natural-number/c))
  c : coverage?
语法
(generate-term from-pattern)
(generate-term from-judgment-form)
(generate-term from-metafunction)
(generate-term from-reduction-relation)
 
           from-pattern = language pattern size-expr kw-args ...
                        | language pattern
                        | language pattern #:i-th index-expr
                        | language pattern #:i-th
                           
     from-judgment-form = language #:satisfying
                          (judgment-form-id pattern ...)
                        | language #:satisfying
                          (judgment-form-id pattern ...)
                          size-expr
                           
      from-metafunction = language #:satisfying
                          (metafunction-id pattern ...) = pattern
                        | language #:satisfying
                          (metafunction-id pattern ...) = pattern
                          size-expr
                        | #:source metafunction size-expr kw-args
                        | #:source metafunction
                           
from-reduction-relation = #:source reduction-relation-expr
                          size-expr kw-args ...
                        | #:source reduction-relation-expr
                           
                kw-args = #:attempt-num attempts-expr
                        | #:retries retries-expr
 
  size-expr : natural-number/c
  attempt-num-expr : natural-number/c
  retries-expr : natural-number/c
语法
(redex-enum language pattern)
语法
(redex-index language pattern term)
语法
(redex-check template property-expr kw-arg ...)
 
template = language pattern
         | language pattern #:ad-hoc
         | language pattern #:in-order
         | language pattern #:uniform-at-random p-value
         | language pattern #:enum bound
         | language #:satisfying
           (judgment-form-id pattern ...)
         | language #:satisfying
           (metafunction-id pattern ...) = pattern
            
  kw-arg = #:attempts attempts-expr
         | #:source metafunction
         | #:source relation-expr
         | #:retries retries-expr
         | #:print? print?-expr
         | #:attempt-size attempt-size-expr
         | #:prepare prepare-expr
         | #:keep-going? keep-going?-expr
 
  property-expr : any/c
  attempts-expr : natural-number/c
  relation-expr : reduction-relation?
  retries-expr : natural-number/c
  print?-expr : any/c
  attempt-size-expr : (-> natural-number/c natural-number/c)
  prepare-expr : (-> any/c any/c)
parameter
(depth-dependent-order?) -> (or/c boolean? 'random)
(depth-dependent-order? depth-dependent) -> void?
  depth-dependent : (or/c boolean? 'random)
 = 'random
语法
(redex-generator language-id satisfying size-expr)
 
satisfying = (judgment-form-id pattern ...)
           | (metafunction-id pattern ...) = pattern
 
  size-expr : natural-number/c
struct
(struct counterexample (term)
    #:extra-constructor-name make-counterexample
    #:transparent)
  term : any/c
struct
(struct exn:fail:redex:test exn:fail:redex (source term)
    #:extra-constructor-name make-exn:fail:redex:test)
  source : exn:fail?
  term : any/c
语法
(check-reduction-relation relation property kw-args ...)
 
kw-arg = #:attempts attempts-expr
       | #:retries retries-expr
       | #:print? print?-expr
       | #:attempt-size attempt-size-expr
       | #:prepare prepare-expr
 
  property : (-> any/c any/c)
  attempts-expr : natural-number/c
  retries-expr : natural-number/c
  print?-expr : any/c
  attempt-size-expr : (-> natural-number/c natural-number/c)
  prepare-expr : (-> any/c any/c)
语法
(check-metafunction metafunction property kw-args ...)
 
kw-arg = #:attempts attempts-expr
       | #:retries retries-expr
       | #:print? print?-expr
       | #:attempt-size attempt-size-expr
       | #:prepare prepare-expr
 
  property : (-> (listof any/c) any/c)
  attempts-expr : natural-number/c
  retries-expr : natural-number/c
  print?-expr : any/c
  attempt-size-expr : (-> natural-number/c natural-number/c)
  prepare-expr : (-> (listof any/c) (listof any/c))
函数
(default-attempt-size n) -> natural-number/c
  n : natural-number/c
parameter
(default-check-attempts) -> natural-number/c
(default-check-attempts attempts) -> void?
  attempts : natural-number/c
parameter
(redex-pseudo-random-generator) -> pseudo-random-generator?
(redex-pseudo-random-generator generator) -> void?
  generator : pseudo-random-generator?
函数
(exn:fail:redex:generation-failure? v) -> boolean?
  v : any/c
函数
(traces  reductions                                        
         expr                                              
        [#:multiple? multiple?                             
         #:reduce reduce                                   
         #:pred pred                                       
         #:pp pp                                           
         #:colors colors                                   
         #:racket-colors? racket-colors?                   
         #:scheme-colors? scheme-colors?                   
         #:filter term-filter                              
         #:x-spacing x-spacing                             
         #:y-spacing y-spacing                             
         #:layout layout                                   
         #:edge-labels? edge-labels?                       
         #:edge-label-font edge-label-font                 
         #:graph-pasteboard-mixin graph-pasteboard-mixin]) 
 -> void?
  reductions : (or/c reduction-relation? IO-judgment-form?)
  expr : (or/c any/c (listof any/c))
  multiple? : boolean? = #f
  reduce : (-> reduction-relation? any/c
               (listof (list/c (union false/c string?) any/c)))
         = apply-reduction-relation/tag-with-names
  pred : (or/c (-> sexp any)             = (λ (x) #t)
               (-> sexp term-node? any))
  pp : (or/c (any -> string)
             (any output-port number (is-a?/c text%) -> void))
     = default-pretty-printer
  colors : (listof
            (cons/c string?
                    (and/c (listof (or/c string? (is-a?/c color%)))
                           (λ (x) (<= 0 (length x) 6)))))
         = '()
  racket-colors? : boolean? = #t
  scheme-colors? : boolean? = racket-colors?
  term-filter : (-> any/c (or/c #f string?) any/c)
              = (λ (x y) #t)
  x-spacing : real? = 15
  y-spacing : real? = 15
  layout : (-> (listof term-node?) void?) = void
  edge-labels? : boolean? = #t
  edge-label-font : (or/c #f (is-a?/c font%)) = #f
  graph-pasteboard-mixin : (make-mixin-contract graph-pasteboard<%>)
                         = values
函数
(traces/ps  reductions                                       
            expr                                             
            file                                             
           [#:multiple? multiple?                            
            #:reduce reduce                                  
            #:pred pred                                      
            #:pp pp                                          
            #:colors colors                                  
            #:filter term-filter                             
            #:layout layout                                  
            #:x-spacing x-spacing                            
            #:y-spacing y-spacing                            
            #:edge-labels? edge-labels?                      
            #:edge-label-font edge-label-font                
            #:graph-pasteboard-mixin graph-pasteboard-mixin] 
            #:post-process post-process)                     
 -> void?
  reductions : (or/c reduction-relation? IO-judgment-form?)
  expr : (or/c any/c (listof any/c))
  file : (or/c path-string? path?)
  multiple? : boolean? = #f
  reduce : (-> reduction-relation? any/c
               (listof (list/c (union false/c string?) any/c)))
         = apply-reduction-relation/tag-with-names
  pred : (or/c (-> sexp any)             = (λ (x) #t)
               (-> sexp term-node? any))
  pp : (or/c (any -> string)
             (any output-port number (is-a?/c text%) -> void))
     = default-pretty-printer
  colors : (listof
            (cons/c string?
                    (and/c (listof (or/c string? (is-a?/c color%)))
                           (λ (x) (<= 0 (length x) 6)))))
         = '()
  term-filter : (-> any/c (or/c #f string?) any/c)
              = (λ (x y) #t)
  layout : (-> (listof term-node?) void?) = void
  x-spacing : number? = 15
  y-spacing : number? = 15
  edge-labels? : boolean? = #t
  edge-label-font : (or/c #f (is-a?/c font%)) = #f
  graph-pasteboard-mixin : (make-mixin-contract graph-pasteboard<%>)
                         = values
  post-process : (-> (is-a?/c graph-pasteboard<%>) any/c)
函数
(stepper reductions t [pp]) -> void?
  reductions : (or/c reduction-relation? IO-judgment-form?)
  t : any/c
  pp : (or/c (any -> string)
             (any output-port number (is-a?/c text%) -> void))
     = default-pretty-printer
函数
(stepper/seed reductions seed [pp]) -> void?
  reductions : (or/c reduction-relation? IO-judgment-form?)
  seed : (cons/c any/c (listof any/c))
  pp : (or/c (any -> string)
             (any output-port number (is-a?/c text%) -> void))
     = default-pretty-printer
函数
(show-derivations  derivations                             
                  [#:pp pp                                 
                   #:racket-colors? racket-colors?         
                   #:init-derivation init-derivation]) -> any
  derivations : (cons/c derivation? (listof derivation?))
  pp : (or/c (any -> string)
             (any output-port number (is-a?/c text%) -> void))
     = default-pretty-printer
  racket-colors? : boolean? = #f
  init-derivation : exact-nonnegative-integer? = 0
函数
(derivation/ps  derivation                           
                filename                             
               [#:pp pp                              
                #:racket-colors? racket-colors?]     
                #:post-process post-process)     -> void?
  derivation : derivation?
  filename : path-string?
  pp : (or/c (any -> string)
             (any output-port number (is-a?/c text%) -> void))
     = default-pretty-printer
  racket-colors? : boolean? = #f
  post-process : (-> (is-a?/c pasteboard%) any)
函数
(term-node-children tn) -> (listof term-node?)
  tn : term-node?
函数
(term-node-parents tn) -> (listof term-node?)
  tn : term-node?
函数
(term-node-labels tn) -> (listof (or/c false/c string?))
  tn : term-node?
函数
(term-node-set-color! tn color) -> void?
  tn : term-node?
  color : (or/c string? (is-a?/c color%) false/c)
函数
(term-node-color tn) -> (or/c string? (is-a?/c color%) false/c)
  tn : term-node?
函数
(term-node-set-red! tn red?) -> void?
  tn : term-node?
  red? : boolean?
函数
(term-node-expr tn) -> any
  tn : term-node?
函数
(term-node-set-position! tn x y) -> void?
  tn : term-node?
  x : (and/c real? positive?)
  y : (and/c real? positive?)
函数
(term-node-x tn) -> real?
  tn : term-node?
函数
(term-node-y tn) -> real?
  tn : term-node?
函数
(term-node-width tn) -> real?
  tn : term-node?
函数
(term-node-height tn) -> real?
  tn : term-node?
函数
(term-node? v) -> boolean?
  v : any/c
parameter
(reduction-steps-cutoff) -> number?
(reduction-steps-cutoff cutoff) -> void?
  cutoff : number?
parameter
(initial-font-size) -> number?
(initial-font-size size) -> void?
  size : number?
parameter
(initial-char-width) -> (or/c number? (-> any/c number?))
(initial-char-width width) -> void?
  width : (or/c number? (-> any/c number?))
parameter
(dark-pen-color) -> (or/c string? (is-a?/c color<%>))
(dark-pen-color color) -> void?
  color : (or/c string? (is-a?/c color<%>))
parameter
(dark-brush-color) -> (or/c string? (is-a?/c color<%>))
(dark-brush-color color) -> void?
  color : (or/c string? (is-a?/c color<%>))
parameter
(light-pen-color) -> (or/c string? (is-a?/c color<%>))
(light-pen-color color) -> void?
  color : (or/c string? (is-a?/c color<%>))
parameter
(light-brush-color) -> (or/c string? (is-a?/c color<%>))
(light-brush-color color) -> void?
  color : (or/c string? (is-a?/c color<%>))
parameter
(dark-text-color) -> (or/c string? (is-a?/c color<%>))
(dark-text-color color) -> void?
  color : (or/c string? (is-a?/c color<%>))
parameter
(light-text-color) -> (or/c string? (is-a?/c color<%>))
(light-text-color color) -> void?
  color : (or/c string? (is-a?/c color<%>))
parameter
(pretty-print-parameters) -> (-> (-> any/c) any/c)
(pretty-print-parameters f) -> void?
  f : (-> (-> any/c) any/c)
函数
(default-pretty-printer v port width text) -> void?
  v : any/c
  port : output-port?
  width : exact-nonnegative-integer?
  text : (is-a?/c text%)
语法
(render-term lang term)
(render-term lang term file)
语法
(term->pict lang term)
函数
(render-term/pretty-write  lang                
                           term                
                          [filename            
                           #:width width]) -> (or/c void? pict?)
  lang : compiled-lang?
  term : any/c
  filename : (or/c path-string? #f) = #f
  width : (or/c exact-positive-integer? 'infinity)
        = (pretty-print-columns)
函数
(term->pict/pretty-write  lang                
                          term                
                         [#:width width]) -> pict?
  lang : compiled-lang?
  term : any/c
  width : (or/c exact-positive-integer? 'infinity)
        = (pretty-print-columns)
函数
(render-language lang [file #:nts nts]) -> (if file void? pict?)
  lang : compiled-lang?
  file : (or/c false/c path-string?) = #f
  nts : (or/c false/c (listof (or/c string? symbol?)))
      = (render-language-nts)
函数
(language->pict lang [#:nts nts]) -> pict?
  lang : compiled-lang?
  nts : (or/c false/c (listof (or/c string? symbol?)))
      = (render-language-nts)
函数
(render-reduction-relation  rel             
                           [file            
                            #:style style]) 
 -> (if file void? pict?)
  rel : reduction-relation?
  file : (or/c false/c path-string?) = #f
  style : reduction-rule-style/c = (rule-pict-style)
函数
(reduction-relation->pict r [#:style style]) -> pict?
  r : reduction-relation?
  style : reduction-rule-style/c = (rule-pict-style)
语法
(render-metafunction metafunction-name maybe-contract)
(render-metafunction metafunction-name filename maybe-contract)
语法
(render-metafunctions metafunction-name ...
                      maybe-filename maybe-contract)
 
 maybe-filename = 
                | #:file filename
                | #:filename filename
                   
maybe-contract? = 
                | #:contract? bool-expr
语法
(metafunction->pict metafunction-name maybe-contract?)
语法
(metafunctions->pict metafunction-name ...)
语法
(render-relation relation-name)
语法
(render-relation relation-name filename)
语法
(render-judgment-form judgment-form-name)
语法
(render-judgment-form judgment-form-name filename)
语法
(relation->pict relation-name)
语法
(judgment-form->pict judgment-form-name)
parameter
(render-language-nts) -> (or/c false/c (listof symbol?))
(render-language-nts nts) -> void?
  nts : (or/c false/c (listof symbol?))
parameter
(non-terminal-gap-space) -> real?
(non-terminal-gap-space gap-space) -> void?
  gap-space : real?
parameter
(extend-language-show-union) -> boolean?
(extend-language-show-union show?) -> void?
  show? : boolean?
parameter
(extend-language-show-extended-order) -> boolean?
(extend-language-show-extended-order ext-order?) -> void?
  ext-order? : boolean?
parameter
(render-reduction-relation-rules)
 -> (or/c false/c
          (listof (or/c symbol?
                        string?
                        exact-nonnegative-integer?)))
(render-reduction-relation-rules rules) -> void?
  rules : (or/c false/c
                (listof (or/c symbol?
                              string?
                              exact-nonnegative-integer?)))
parameter
(rule-pict-style) -> reduction-rule-style/c
(rule-pict-style style) -> void?
  style : reduction-rule-style/c
值
reduction-rule-style/c : contract?
函数
(rule-pict-info? x) -> boolean?
  x : any/c
函数
(rule-pict-info-arrow rule-pict-info) -> symbol?
  rule-pict-info : rule-pict-info?
函数
(rule-pict-info-lhs rule-pict-info) -> pict?
  rule-pict-info : rule-pict-info?
函数
(rule-pict-info-rhs rule-pict-info) -> pict?
  rule-pict-info : rule-pict-info?
函数
(rule-pict-info-label rule-pict-info) -> (or/c symbol? #f)
  rule-pict-info : rule-pict-info?
函数
(rule-pict-info-computed-label rule-pict-info)
 -> (or/c pict? #f)
  rule-pict-info : rule-pict-info?
函数
(rule-pict-info->side-condition-pict  rule-pict-info     
                                     [max-width])    -> pict?
  rule-pict-info : rule-pict-info?
  max-width : real? = +inf.0
parameter
(arrow-space) -> natural-number/c
(arrow-space space) -> void?
  space : natural-number/c
parameter
(label-space) -> natural-number/c
(label-space space) -> void?
  space : natural-number/c
parameter
(metafunction-pict-style)
 -> (or/c 'left-right
          'up-down
          'left-right/vertical-side-conditions
          'up-down/vertical-side-conditions
          'left-right/compact-side-conditions
          'up-down/compact-side-conditions
          'left-right/beside-side-conditions)
(metafunction-pict-style style) -> void?
  style : (or/c 'left-right
                'up-down
                'left-right/vertical-side-conditions
                'up-down/vertical-side-conditions
                'left-right/compact-side-conditions
                'up-down/compact-side-conditions
                'left-right/beside-side-conditions)
parameter
(metafunction-up/down-indent) -> (>=/c 0)
(metafunction-up/down-indent indent) -> void?
  indent : (>=/c 0)
parameter
(delimit-ellipsis-arguments?) -> any/c
(delimit-ellipsis-arguments? delimit?) -> void?
  delimit? : any/c
parameter
(white-square-bracket) -> (-> boolean? pict?)
(white-square-bracket make-white-square-bracket) -> void?
  make-white-square-bracket : (-> boolean? pict?)
函数
(homemade-white-square-bracket open?) -> pict?
  open? : boolean?
函数
(default-white-square-bracket open?) -> pict?
  open? : boolean?
parameter
(linebreaks) -> (or/c #f (listof boolean?))
(linebreaks breaks) -> void?
  breaks : (or/c #f (listof boolean?))
parameter
(sc-linebreaks) -> (or/c #f (listof boolean?))
(sc-linebreaks breaks) -> void?
  breaks : (or/c #f (listof boolean?))
parameter
(metafunction-cases)
 -> (or/c #f (and/c (listof (or/c symbol?
                                  string?
                                  exact-nonnegative-integer?))
                    pair?))
(metafunction-cases cases) -> void?
  cases : (or/c #f (and/c (listof (or/c symbol?
                                        string?
                                        exact-nonnegative-integer?))
                          pair?))
parameter
(judgment-form-cases)
 -> (or/c #f
          (non-empty-listof (or/c symbol?
                                  string?
                                  exact-nonnegative-integer?)))
(judgment-form-cases cases) -> void?
  cases : (or/c #f
                (non-empty-listof (or/c symbol?
                                        string?
                                        exact-nonnegative-integer?)))
parameter
(judgment-form-show-rule-names) -> boolean?
(judgment-form-show-rule-names show-rule-names?) -> void?
  show-rule-names? : boolean?
parameter
(label-style) -> text-style/c
(label-style style) -> void?
  style : text-style/c
parameter
(grammar-style) -> text-style/c
(grammar-style style) -> void?
  style : text-style/c
parameter
(paren-style) -> text-style/c
(paren-style style) -> void?
  style : text-style/c
parameter
(literal-style) -> text-style/c
(literal-style style) -> void?
  style : text-style/c
parameter
(metafunction-style) -> text-style/c
(metafunction-style style) -> void?
  style : text-style/c
parameter
(non-terminal-style) -> text-style/c
(non-terminal-style style) -> void?
  style : text-style/c
parameter
(non-terminal-subscript-style) -> text-style/c
(non-terminal-subscript-style style) -> void?
  style : text-style/c
parameter
(non-terminal-superscript-style) -> text-style/c
(non-terminal-superscript-style style) -> void?
  style : text-style/c
parameter
(default-style) -> text-style/c
(default-style style) -> void?
  style : text-style/c
parameter
(label-font-size) -> (and/c (between/c 1 255) integer?)
(label-font-size size) -> void?
  size : (and/c (between/c 1 255) integer?)
parameter
(metafunction-font-size) -> (and/c (between/c 1 255)
                                   integer?)
(metafunction-font-size size) -> void?
  size : (and/c (between/c 1 255)
                integer?)
parameter
(default-font-size) -> (and/c (between/c 1 255) integer?)
(default-font-size size) -> void?
  size : (and/c (between/c 1 255) integer?)
parameter
(reduction-relation-rule-separation) -> (parameter/c real?)
(reduction-relation-rule-separation sep) -> void?
  sep : (parameter/c real?)
parameter
(reduction-relation-rule-extra-separation)
 -> (parameter/c real?)
(reduction-relation-rule-extra-separation sep) -> void?
  sep : (parameter/c real?)
parameter
(reduction-relation-rule-line-separation)
 -> (parameter/c real?)
(reduction-relation-rule-line-separation sep) -> void?
  sep : (parameter/c real?)
parameter
(curly-quotes-for-strings) -> boolean?
(curly-quotes-for-strings on?) -> void?
  on? : boolean?
parameter
(current-text) -> (-> string? text-style/c number? pict?)
(current-text proc) -> void?
  proc : (-> string? text-style/c number? pict?)
函数
(arrow->pict arrow) -> pict?
  arrow : symbol?
函数
(set-arrow-pict! arrow proc) -> void?
  arrow : symbol?
  proc : (-> pict?)
parameter
(white-bracket-sizing)
 -> (-> string? number? (values number? number? number? number?))
(white-bracket-sizing proc) -> void?
  proc : (-> string? number? (values number? number? number? number?))
parameter
(horizontal-bar-spacing)
 -> (parameter/c exact-nonnegative-integer?)
(horizontal-bar-spacing space) -> void?
  space : (parameter/c exact-nonnegative-integer?)
parameter
(metafunction-gap-space) -> real?
(metafunction-gap-space gap-space) -> void?
  gap-space : real?
parameter
(metafunction-rule-gap-space) -> real?
(metafunction-rule-gap-space gap-space) -> void?
  gap-space : real?
parameter
(metafunction-line-gap-space) -> real?
(metafunction-line-gap-space gap-space) -> void?
  gap-space : real?
parameter
(metafunction-fill-acceptable-width) -> real?
(metafunction-fill-acceptable-width width) -> void?
  width : real?
parameter
(metafunction-combine-contract-and-rules)
 -> (pict? pict? . -> . pict?)
(metafunction-combine-contract-and-rules combine) -> void?
  combine : (pict? pict? . -> . pict?)
parameter
(relation-clauses-combine)
 -> (parameter/c (-> (listof pict?) pict?))
(relation-clauses-combine combine) -> void?
  combine : (parameter/c (-> (listof pict?) pict?))
parameter
(metafunction-arrow-pict) -> (parameter/c (-> pict?))
(metafunction-arrow-pict make-arrow) -> void?
  make-arrow : (parameter/c (-> pict?))
parameter
(where-make-prefix-pict) -> (parameter/c (-> pict?))
(where-make-prefix-pict make-prefix) -> void?
  make-prefix : (parameter/c (-> pict?))
parameter
(where-combine) -> (parameter/c (-> pict? pict? pict?))
(where-combine combine) -> void?
  combine : (parameter/c (-> pict? pict? pict?))
parameter
(current-render-pict-adjust) -> (pict? symbol? . -> . pict?)
(current-render-pict-adjust adjust) -> void?
  adjust : (pict? symbol? . -> . pict?)
语法
(with-unquote-rewriter proc expression)
语法
(with-atomic-rewriter name-symbol
                      string-or-thunk-returning-pict
                      expression)
语法
(with-atomic-rewriters ([name-symbol string-or-thunk-returning-pict] ...)
                         expression)
语法
(with-compound-rewriter name-symbol
                        proc
                        expression)
语法
(with-compound-rewriters ([name-symbol proc] ...)
                         expression)
struct
(struct lw (e
            line
            line-span
            column
            column-span
            unq?
            metafunction?)
    #:extra-constructor-name make-lw
    #:mutable)
  e : (or/c string?
            symbol?
            pict?
            (listof (or/c (symbols 'spring) lw?)))
  line : exact-positive-integer?
  line-span : exact-positive-integer?
  column : exact-positive-integer?
  column-span : exact-positive-integer?
  unq? : boolean?
  metafunction? : boolean?
函数
(build-lw e line line-span column column-span) -> lw?
  e : (or/c string?
            symbol?
            pict?
            (listof (or/c 'spring lw?)))
  line : exact-positive-integer?
  line-span : exact-positive-integer?
  column : exact-positive-integer?
  column-span : exact-positive-integer?
语法
(to-lw arg)
函数
(to-lw/stx stx) -> lw?
  stx : syntax?
函数
(render-lw language/nts lw) -> pict?
  language/nts : (or/c (listof symbol?) compiled-lang?)
  lw : lw?
函数
(lw->pict language/ntw lw) -> pict?
  language/ntw : (or/c (listof symbol?) compiled-lang?)
  lw : lw?
函数
(just-before stuff lw) -> lw?
  stuff : (or/c pict? string? symbol?)
  lw : lw?
函数
(just-after stuff lw) -> lw?
  stuff : (or/c pict? string? symbol?)
  lw : lw?
函数
(fill-between stuff lw-before lw-after) -> lw?
  stuff : (or/c pict? string? symbol?)
  lw-before : lw?
  lw-after : lw?
语法
(define-rewrite id from ==> to
  [#:context (context-id ...)
   #:variables (variable-id ...)
   #:once-only
   #:exactly-once])
语法
(define-rewrite/compose id rw-id ...)
语法
(include/rewrite path-spec mod-id rw-id ...)
函数
(run-gen-and-check  get-gen           
                    check             
                    seconds           
                   [#:name name       
                    #:type type]) -> run-results?
  get-gen : (-> (-> any/c))
  check : (-> any/c boolean?)
  seconds : natural-number/c
  name : string? = "unknown"
  type : symbol? = 'unknown
struct
(struct run-results (tries time cexps))
  tries : natural-number/c
  time : natural-number/c
  cexps : natural-number/c
函数
(run-gen-and-check/mods  gen-mod-path       
                         check-mod-path     
                         seconds            
                        [#:name name])  -> run-results?
  gen-mod-path : module-path?
  check-mod-path : module-path?
  seconds : natural-number/c
  name : string? = "unknown"
struct
(struct bmark-log-data (data))
  data : any/c
函数
(benchmark-logging-to filename thunk) -> any/c
  filename : string?
  thunk : (-> any/c)
parameter
(bmark-log-directory)
 -> (or/c path-string? path-for-some-system? 'up 'same)
(bmark-log-directory directory) -> void?
  directory : (or/c path-string? path-for-some-system? 'up 'same)
 = (current-directory)
函数
(all-mods)
 -> (listof (list/c string? module-path? module-path?))
