8409
((3) 0 () 8 ((q lib "plai/mutator.rkt") (q lib "plai/scribblings/fake-collector2.rkt") (q lib "plai/gc2/mutator.rkt") (q lib "plai/collector.rkt") (q lib "plai/gc2/collector.rkt") (q lib "plai/scribblings/fake-collector.rkt") (q lib "plai/main.rkt") (q lib "plai/random-mutator.rkt")) () (h ! (equal) ((c form c (c (? . 0) q import-primitives)) q (4000 . 2)) ((c def c (c (? . 1) q gc:closure-code-ptr)) q (5955 . 3)) ((c def c (c (? . 6) q plai-catch-test-exn)) q (679 . 3)) ((c def c (c (? . 3) q procedure-roots)) q (1625 . 3)) ((c form c (c (? . 2) q let)) q (6406 . 2)) ((c form c (c (? . 0) q let*)) q (2866 . 2)) ((c form c (c (? . 0) q cond)) q (2792 . 2)) ((c def c (c (? . 1) q gc:set-rest!)) q (5605 . 4)) ((c def c (c (? . 7) q save-random-mutator)) q (7756 . 16)) ((c def c (c (? . 2) q odd?)) q (6854 . 2)) ((c def c (c (? . 0) q boolean?)) q (3498 . 2)) ((c def c (c (? . 0) q sub1)) q (3127 . 2)) ((c form c (c (? . 2) q case)) q (6373 . 2)) ((c def c (c (? . 0) q first)) q (3690 . 3)) ((c def c (c (? . 3) q heap-set!)) q (1305 . 4)) ((c form c (c (? . 2) q print-only-errors)) q (7496 . 2)) ((c form c (c (? . 2) q halt-on-errors)) q (7521 . 2)) ((c form c (c (? . 0) q quote)) q (2890 . 2)) ((c def c (c (? . 1) q gc:cons?)) q (5718 . 3)) ((c def c (c (? . 5) q gc:cons?)) q (2513 . 3)) ((c form c (c (? . 2) q define)) q (6485 . 2)) ((c def c (c (? . 1) q gc:set-first!)) q (5489 . 4)) ((c def c (c (? . 2) q cons)) q (7144 . 4)) ((c def c (c (? . 4) q heap-ref)) q (4511 . 3)) ((c form c (c (? . 0) q begin)) q (2903 . 2)) ((c def c (c (? . 2) q number?)) q (7040 . 2)) ((c def c (c (? . 1) q init-allocator)) q (5098 . 2)) ((c def c (c (? . 2) q <)) q (6899 . 2)) ((c def c (c (? . 1) q gc:alloc-flat)) q (5195 . 3)) ((c def c (c (? . 0) q print-only-errors)) q (3929 . 2)) ((q def ((lib "plai/scribblings/fake-web.rkt") start)) q (8664 . 3)) ((c form c (c (? . 2) q λ)) q (6597 . 2)) ((c form c (c (? . 3) q with-heap)) q (1701 . 4)) ((c def c (c (? . 4) q make-root)) q (4791 . 5)) ((c def c (c (? . 5) q gc:flat?)) q (2572 . 3)) ((c form c (c (? . 2) q and)) q (6340 . 2)) ((c form c (c (? . 0) q if)) q (2761 . 2)) ((c def c (c (? . 1) q gc:closure?)) q (6138 . 3)) ((c def c (c (? . 1) q gc:first)) q (5346 . 3)) ((c def c (c (? . 4) q heap-size)) q (4220 . 2)) ((c def c (c (? . 5) q gc:first)) q (2141 . 3)) ((q form ((lib "plai/scribblings/fake-mutator2.rkt") allocator-setup)) q (6200 . 5)) ((c form c (c (? . 6) q define-type)) q (0 . 5)) ((c def c (c (? . 2) q even?)) q (6829 . 2)) ((c form c (c (? . 0) q empty)) q (3916 . 2)) ((c def c (c (? . 3) q read-root)) q (1484 . 3)) ((c def c (c (? . 2) q cons?)) q (7211 . 3)) ((c def c (c (? . 4) q location?)) q (4271 . 3)) ((c def c (c (? . 5) q gc:rest)) q (2213 . 3)) ((c form c (c (? . 0) q define-values)) q (2816 . 2)) ((c def c (c (? . 1) q gc:closure-env-ref)) q (6028 . 4)) ((c form c (c (? . 0) q test/location=?)) q (4036 . 2)) ((c def c (c (? . 2) q error)) q (6647 . 2)) ((c def c (c (? . 7) q find-heap-values)) q (8556 . 3)) ((c def c (c (? . 4) q simple-root)) q (4736 . 3)) ((c def c (c (? . 0) q cons)) q (3575 . 4)) ((c def c (c (? . 3) q set-root!)) q (1543 . 4)) ((c form c (c (? . 6) q type-case)) q (154 . 6)) ((c form c (c (? . 0) q let-values)) q (2848 . 2)) ((c form c (c (? . 0) q and)) q (2771 . 2)) ((c def c (c (? . 3) q heap-value?)) q (1251 . 3)) ((c def c (c (? . 5) q init-allocator)) q (1885 . 2)) ((c form c (c (? . 0) q test/value=?)) q (4091 . 2)) ((c def c (c (? . 0) q empty?)) q (3526 . 2)) ((c def c (c (? . 6) q abridged-test-output)) q (590 . 3)) ((c def c (c (? . 0) q set-first!)) q (3779 . 4)) ((c def c (c (? . 3) q heap-size)) q (1100 . 2)) ((c def c (c (? . 2) q boolean?)) q (7067 . 2)) ((c def c (c (? . 6) q test-inexact-epsilon)) q (919 . 3)) ((c def c (c (? . 4) q read-root)) q (4595 . 3)) ((c def c (c (? . 5) q gc:cons)) q (2049 . 4)) ((c def c (c (? . 0) q even?)) q (3260 . 2)) ((c def c (c (? . 2) q >)) q (6920 . 2)) ((c def c (c (? . 2) q first)) q (7259 . 3)) ((c form c (c (? . 2) q or)) q (6351 . 2)) ((c form c (c (? . 4) q with-heap)) q (4921 . 4)) ((c form c (c (? . 2) q empty)) q (7483 . 2)) ((c def c (c (? . 2) q >=)) q (6963 . 2)) ((c def c (c (? . 2) q -)) q (6766 . 2)) ((c def c (c (? . 5) q gc:set-first!)) q (2284 . 4)) ((c def c (c (? . 0) q symbol?)) q (3416 . 2)) ((c form c (c (? . 2) q begin)) q (6472 . 2)) ((c def c (c (? . 1) q gc:cons)) q (5262 . 4)) ((c form c (c (? . 4) q get-root-set)) q (4573 . 2)) ((c form c (c (? . 2) q lambda)) q (6543 . 2)) ((q form ((lib "plai/scribblings/fake-mutator.rkt") allocator-setup)) q (2631 . 5)) ((c def c (c (? . 0) q eq?)) q (3552 . 2)) ((c form c (c (? . 6) q plai-all-test-results)) q (1071 . 2)) ((c form c (c (? . 6) q test/pred)) q (351 . 2)) ((c def c (c (? . 6) q print-only-errors)) q (838 . 3)) ((c form c (c (? . 3) q with-roots)) q (1792 . 4)) ((c def c (c (? . 6) q error)) q (390 . 2)) ((c def c (c (? . 6) q equal~?)) q (517 . 4)) ((c form c (c (? . 0) q or)) q (2782 . 2)) ((c form c (c (? . 2) q define-values)) q (6385 . 2)) ((c def c (c (? . 0) q -)) q (3197 . 2)) ((c def c (c (? . 6) q halt-on-errors)) q (762 . 3)) ((c def c (c (? . 1) q gc:flat?)) q (5777 . 3)) ((c form c (c (? . 3) q get-root-set)) q (1453 . 2)) ((c form c (c (? . 2) q test/value=?)) q (7634 . 2)) ((c form c (c (? . 0) q set!)) q (2878 . 2)) ((c form c (c (? . 0) q printf)) q (4148 . 4)) ((c def c (c (? . 0) q add1)) q (3103 . 2)) ((c def c (c (? . 0) q +)) q (3176 . 2)) ((c def c (c (? . 5) q gc:deref)) q (1920 . 3)) ((c form c (c (? . 0) q case)) q (2804 . 2)) ((c def c (c (? . 0) q >)) q (3351 . 2)) ((c form c (c (? . 2) q let-values)) q (6417 . 2)) ((c form c (c (? . 2) q if)) q (6330 . 2)) ((c form c (c (? . 6) q test/regexp)) q (461 . 2)) ((c def c (c (? . 0) q set-rest!)) q (3848 . 4)) ((c def c (c (? . 0) q *)) q (3218 . 2)) ((c def c (c (? . 2) q sub1)) q (6696 . 2)) ((c form c (c (? . 4) q with-roots)) q (5012 . 4)) ((c def c (c (? . 2) q =)) q (6878 . 2)) ((c def c (c (? . 2) q empty?)) q (7095 . 2)) ((c def c (c (? . 4) q heap-value?)) q (4371 . 3)) ((c def c (c (? . 1) q gc:closure)) q (5836 . 4)) ((c form c (c (? . 0) q define)) q (2916 . 2)) ((c def c (c (? . 0) q /)) q (3239 . 2)) ((c form c (c (? . 2) q let*)) q (6435 . 2)) ((c def c (c (? . 2) q set-first!)) q (7348 . 4)) ((c def c (c (? . 3) q root?)) q (1203 . 3)) ((c form c (c (? . 2) q test/location=?)) q (7579 . 2)) ((c form c (c (? . 2) q import-primitives)) q (7543 . 2)) ((c def c (c (? . 3) q location?)) q (1151 . 3)) ((c form c (c (? . 2) q cond)) q (6361 . 2)) ((c def c (c (? . 2) q /)) q (6808 . 2)) ((c def c (c (? . 4) q heap-set!)) q (4425 . 4)) ((c def c (c (? . 0) q halt-on-errors)) q (3966 . 2)) ((c def c (c (? . 0) q <)) q (3330 . 2)) ((c def c (c (? . 2) q +)) q (6745 . 2)) ((c def c (c (? . 0) q number?)) q (3471 . 2)) ((c form c (c (? . 2) q quote)) q (6459 . 2)) ((c def c (c (? . 4) q root?)) q (4323 . 3)) ((c def c (c (? . 2) q symbol?)) q (6985 . 2)) ((c def c (c (? . 1) q gc:rest)) q (5418 . 3)) ((c def c (c (? . 5) q gc:set-rest!)) q (2400 . 4)) ((c form c (c (? . 0) q lambda)) q (2974 . 2)) ((c form c (c (? . 0) q let)) q (2837 . 2)) ((c form c (c (? . 2) q printf)) q (7684 . 4)) ((c def c (c (? . 0) q >=)) q (3394 . 2)) ((c def c (c (? . 5) q gc:alloc-flat)) q (1982 . 3)) ((c def c (c (? . 6) q plai-ignore-exn-strings)) q (993 . 3)) ((c def c (c (? . 2) q *)) q (6787 . 2)) ((c def c (c (? . 2) q zero?)) q (6720 . 2)) ((c def c (c (? . 3) q heap-ref)) q (1391 . 3)) ((c def c (c (? . 2) q add1)) q (6672 . 2)) ((c def c (c (? . 0) q =)) q (3309 . 2)) ((c def c (c (? . 4) q set-root!)) q (4654 . 4)) ((c def c (c (? . 0) q odd?)) q (3285 . 2)) ((c form c (c (? . 0) q λ)) q (3028 . 2)) ((c def c (c (? . 1) q gc:deref)) q (5133 . 3)) ((c def c (c (? . 0) q zero?)) q (3151 . 2)) ((c def c (c (? . 0) q rest)) q (3735 . 3)) ((c def c (c (? . 0) q symbol=?)) q (3443 . 2)) ((c form c (c (? . 6) q test)) q (309 . 2)) ((c def c (c (? . 2) q symbol=?)) q (7012 . 2)) ((c def c (c (? . 2) q eq?)) q (7121 . 2)) ((c def c (c (? . 2) q rest)) q (7304 . 3)) ((c def c (c (? . 0) q <=)) q (3372 . 2)) ((c form c (c (? . 2) q set!)) q (6447 . 2)) ((c def c (c (? . 2) q <=)) q (6941 . 2)) ((c def c (c (? . 0) q error)) q (3078 . 2)) ((c def c (c (? . 0) q cons?)) q (3642 . 3)) ((c form c (c (? . 6) q test/exn)) q (415 . 2)) ((c def c (c (? . 2) q set-rest!)) q (7416 . 4))))
语法
(define-type type-id variant ...)
(define-type type-id #:immutable variant ...)
 
variant = (variant-id (field-id contract-expr) ...)
语法
(type-case datatype-id expr
   branch ...)
 
branch = (variant-id (field-id ...) result-expr ...)
       | (else result-expr ...)
语法
(test result-expr expected-expr)
语法
(test/pred result-expr pred?)
值
error : procedure?
语法
(test/exn result-expr error-message)
语法
(test/regexp result-expr error-message-regexp)
函数
(equal~? v1 v2) -> boolean?
  v1 : any/c
  v2 : any/c
函数
(abridged-test-output [abridge?]) -> void?
  abridge? : boolean? = false
函数
(plai-catch-test-exn [catch?]) -> void?
  catch? : boolean? = true
函数
(halt-on-errors [halt?]) -> void?
  halt? : boolean? = true
函数
(print-only-errors [print?]) -> void?
  print? : boolean? = true
函数
(test-inexact-epsilon epsilon) -> void?
  epsilon : number?
函数
(plai-ignore-exn-strings ignore?) -> void?
  ignore? : boolean?
语法
plai-all-test-results
函数
(heap-size) -> exact-nonnegative-integer?
函数
(location? v) -> boolean?
  v : any/c
函数
(root? v) -> boolean?
  v : any/c
函数
(heap-value? v) -> boolean?
  v : any/c
函数
(heap-set! loc val) -> void?
  loc : location?
  val : heap-value?
函数
(heap-ref loc) -> heap-value?
  loc : location?
语法
(get-root-set id ...)
函数
(read-root root) -> location?
  root : root?
函数
(set-root! root loc) -> void?
  root : root?
  loc : location?
函数
(procedure-roots proc) -> (listof root?)
  proc : procedure?
语法
(with-heap heap-expr body-expr ...)
 
  heap-expr : (vectorof heap-value?)
语法
(with-roots roots-expr expr1 expr2 ...)
 
  roots-expr : (listof location?)
函数
(init-allocator) -> void?
函数
(gc:deref loc) -> heap-value?
  loc : location?
函数
(gc:alloc-flat val) -> location?
  val : heap-value?
函数
(gc:cons first rest) -> location?
  first : location?
  rest : location?
函数
(gc:first cons-cell) -> location?
  cons-cell : location?
函数
(gc:rest cons-cell) -> location?
  cons-cell : location?
函数
(gc:set-first! cons-cell first-value) -> void?
  cons-cell : location?
  first-value : location?
函数
(gc:set-rest! cons-cell rest-value) -> void?
  cons-cell : location?
  rest-value : location?
函数
(gc:cons? loc) -> boolean?
  loc : location?
函数
(gc:flat? loc) -> boolean?
  loc : location?
语法
(allocator-setup collector-module
                 heap-size)
 
heap-size = exact-nonnegative-integer
语法
if
语法
and
语法
or
语法
cond
语法
case
语法
define-values
语法
let
语法
let-values
语法
let*
语法
set!
语法
quote
语法
begin
语法
(define (id arg-id ...) body-expression ...+)
语法
(lambda (arg-id ...) body-expression ...+)
语法
(λ (arg-id ...) body-expression ...+)
值
error : procedure?
值
add1 : procedure?
值
sub1 : procedure?
值
zero? : procedure?
值
+ : procedure?
值
- : procedure?
值
* : procedure?
值
/ : procedure?
值
even? : procedure?
值
odd? : procedure?
值
= : procedure?
值
< : procedure?
值
> : procedure?
值
<= : procedure?
值
>= : procedure?
值
symbol? : procedure?
值
symbol=? : procedure?
值
number? : procedure?
值
boolean? : procedure?
值
empty? : procedure?
值
eq? : procedure?
函数
(cons hd tl) -> cons?
  hd : any/c
  tl : any/c
函数
(cons? v) -> boolean?
  v : any/c
函数
(first c) -> any/c
  c : cons?
函数
(rest c) -> any/c
  c : cons?
函数
(set-first! c v) -> void?
  c : cons?
  v : any/c
函数
(set-rest! c v) -> void?
  c : cons?
  v : any/c
语法
empty
值
print-only-errors : procedure?
值
halt-on-errors : procedure?
语法
(import-primitives id ...)
语法
(test/location=? mutator-expr1 mutator-expr2)
语法
(test/value=? mutator-expr scheme-datum/quoted)
语法
(printf format mutator-expr ...)
 
format = literal-string
函数
(heap-size) -> exact-nonnegative-integer?
函数
(location? v) -> boolean?
  v : any/c
函数
(root? v) -> boolean?
  v : any/c
函数
(heap-value? v) -> boolean?
  v : any/c
函数
(heap-set! loc val) -> void?
  loc : location?
  val : heap-value?
函数
(heap-ref loc) -> heap-value?
  loc : location?
语法
(get-root-set)
函数
(read-root root) -> location?
  root : root?
函数
(set-root! root loc) -> void?
  root : root?
  loc : location?
函数
(simple-root l) -> root?
  l : location?
函数
(make-root name get set) -> root?
  name : symbol?
  get : (-> location?)
  set : (-> location? void?)
语法
(with-heap heap-expr body-expr ...)
 
  heap-expr : (vectorof heap-value?)
语法
(with-roots (root-var ...) expr1 expr2 ...)
 
  root-var : location?
函数
(init-allocator) -> void?
函数
(gc:deref loc) -> heap-value?
  loc : location?
函数
(gc:alloc-flat val) -> location?
  val : heap-value?
函数
(gc:cons first rest) -> location?
  first : root?
  rest : root?
函数
(gc:first cons-cell) -> location?
  cons-cell : location?
函数
(gc:rest cons-cell) -> location?
  cons-cell : location?
函数
(gc:set-first! cons-cell first-value) -> void?
  cons-cell : location?
  first-value : location?
函数
(gc:set-rest! cons-cell rest-value) -> void?
  cons-cell : location?
  rest-value : location?
函数
(gc:cons? loc) -> boolean?
  loc : location?
函数
(gc:flat? loc) -> boolean?
  loc : location?
函数
(gc:closure code-ptr free-vars) -> location?
  code-ptr : heap-value?
  free-vars : (listof root?)
函数
(gc:closure-code-ptr loc) -> heap-value?
  loc : location?
函数
(gc:closure-env-ref loc i) -> location?
  loc : location?
  i : exact-nonnegative-integer?
函数
(gc:closure? loc) -> boolean?
  loc : location?
语法
(allocator-setup collector-module
                 heap-size)
 
heap-size = exact-nonnegative-integer
语法
if
语法
and
语法
or
语法
cond
语法
case
语法
define-values
语法
let
语法
let-values
语法
let*
语法
set!
语法
quote
语法
begin
语法
(define (id arg-id ...) body-expression ...+)
语法
(lambda (arg-id ...) body-expression ...+)
语法
(λ (arg-id ...) body-expression ...+)
值
error : procedure?
值
add1 : procedure?
值
sub1 : procedure?
值
zero? : procedure?
值
+ : procedure?
值
- : procedure?
值
* : procedure?
值
/ : procedure?
值
even? : procedure?
值
odd? : procedure?
值
= : procedure?
值
< : procedure?
值
> : procedure?
值
<= : procedure?
值
>= : procedure?
值
symbol? : procedure?
值
symbol=? : procedure?
值
number? : procedure?
值
boolean? : procedure?
值
empty? : procedure?
值
eq? : procedure?
函数
(cons hd tl) -> cons?
  hd : any/c
  tl : any/c
函数
(cons? v) -> boolean?
  v : any/c
函数
(first c) -> any/c
  c : cons?
函数
(rest c) -> any/c
  c : cons?
函数
(set-first! c v) -> void
  c : cons?
  v : any/c
函数
(set-rest! c v) -> void
  c : cons?
  v : any/c
语法
empty
语法
print-only-errors
语法
halt-on-errors
语法
(import-primitives id ...)
语法
(test/location=? mutator-expr1 mutator-expr2)
语法
(test/value=? mutator-expr datum/quoted)
语法
(printf format mutator-expr ...)
 
format = literal-string
函数
(save-random-mutator  file                            
                      collector-name                  
                     [#:heap-values heap-values       
                      #:iterations iterations         
                      #:program-size program-size     
                      #:heap-size heap-size           
                      #:gc2? gc2?])               -> void?
  file : path-string?
  collector-name : string?
  heap-values : (cons heap-value? (listof heap-value?))
              = (list 0 1 -1 'x 'y #f #t '())
  iterations : exact-positive-integer? = 200
  program-size : exact-positive-integer? = 10
  heap-size : exact-positive-integer? = 100
  gc2? : boolean? = #f
函数
(find-heap-values input) -> (listof heap-value?)
  input : (or/c path-string? input-port?)
函数
(start initial-request) -> response?
  initial-request : request?
