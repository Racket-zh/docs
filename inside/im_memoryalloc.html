<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>5&nbsp;Memory Allocation</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../doc-site.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../doc-site.js"></script><script type="text/javascript" src="../local-redirect/local-redirect.js"></script><script type="text/javascript" src="../local-redirect/local-user-redirect.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Inside:<span class="mywbr"> &nbsp;</span> Racket C API</a></td></tr></table></div><div class="tocviewsublisttop" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="overview.html" class="tocviewlink" data-pltdoc="x">Overview</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="embedding.html" class="tocviewlink" data-pltdoc="x">Embedding into a Program</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="Writing_Racket_Extensions.html" class="tocviewlink" data-pltdoc="x">Writing Racket Extensions</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="im_values_types.html" class="tocviewlink" data-pltdoc="x">Values and Types</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Memory Allocation</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="im_env.html" class="tocviewlink" data-pltdoc="x">Namespaces and Modules</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="Procedures.html" class="tocviewlink" data-pltdoc="x">Procedures</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="Evaluation.html" class="tocviewlink" data-pltdoc="x">Evaluation</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="exceptions.html" class="tocviewlink" data-pltdoc="x">Exceptions and Escape Continuations</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="threads.html" class="tocviewlink" data-pltdoc="x">Threads</a></td></tr><tr><td align="right">11&nbsp;</td><td><a href="config.html" class="tocviewlink" data-pltdoc="x">Parameterizations</a></td></tr><tr><td align="right">12&nbsp;</td><td><a href="contmarks.html" class="tocviewlink" data-pltdoc="x">Continuation Marks</a></td></tr><tr><td align="right">13&nbsp;</td><td><a href="im_encodings.html" class="tocviewlink" data-pltdoc="x">String Encodings</a></td></tr><tr><td align="right">14&nbsp;</td><td><a href="Bignums__Rationals__and_Complex_Numbers.html" class="tocviewlink" data-pltdoc="x">Bignums, Rationals, and Complex Numbers</a></td></tr><tr><td align="right">15&nbsp;</td><td><a href="Ports_and_the_Filesystem.html" class="tocviewlink" data-pltdoc="x">Ports and the Filesystem</a></td></tr><tr><td align="right">16&nbsp;</td><td><a href="Structures.html" class="tocviewlink" data-pltdoc="x">Structures</a></td></tr><tr><td align="right">17&nbsp;</td><td><a href="security.html" class="tocviewlink" data-pltdoc="x">Security Guards</a></td></tr><tr><td align="right">18&nbsp;</td><td><a href="Custodians.html" class="tocviewlink" data-pltdoc="x">Custodians</a></td></tr><tr><td align="right">19&nbsp;</td><td><a href="Subprocesses.html" class="tocviewlink" data-pltdoc="x">Subprocesses</a></td></tr><tr><td align="right">20&nbsp;</td><td><a href="Miscellaneous_Utilities.html" class="tocviewlink" data-pltdoc="x">Miscellaneous Utilities</a></td></tr><tr><td align="right"></td><td><a href="doc-index.html" class="tocviewlink" data-pltdoc="x">Index</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9658;</a></td><td>5&nbsp;</td><td><a href="" class="tocviewselflink" data-pltdoc="x">Memory Allocation</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right">5.1&nbsp;</td><td><a href="#%28part._im~3a3m%29" class="tocviewlink" data-pltdoc="x">Cooperating with 3m</a></td></tr><tr><td align="right">5.2&nbsp;</td><td><a href="#%28part._.Memory_.Functions%29" class="tocviewlink" data-pltdoc="x">Memory Functions</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">在本页中：</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">5.1<tt>&nbsp;</tt></span><a href="#%28part._im~3a3m%29" class="tocsubseclink" data-pltdoc="x">Cooperating with 3m</a></td></tr><tr><td><span class="tocsublinknumber">5.1.1<tt>&nbsp;</tt></span><a href="#%28part._im~3a3m~3atagged%29" class="tocsubseclink" data-pltdoc="x">Tagged Objects</a></td></tr><tr><td><span class="tocsublinknumber">5.1.2<tt>&nbsp;</tt></span><a href="#%28part._im~3a3m~3astack%29" class="tocsubseclink" data-pltdoc="x">Local Pointers</a></td></tr><tr><td><span class="tocsublinknumber">5.1.3<tt>&nbsp;</tt></span><a href="#%28part._im~3a3m~3amzc%29" class="tocsubseclink" data-pltdoc="x">Local Pointers and <span class="stt">raco ctool</span> <span class="nobreak"><span class="stt">-<wbr></wbr>-xform</span></span></a></td></tr><tr><td><span class="tocsublinknumber">5.1.4<tt>&nbsp;</tt></span><a href="#%28part._im~3a3m~3amacros%29" class="tocsubseclink" data-pltdoc="x">Guiding <span class="stt">raco ctool</span> <span class="nobreak"><span class="stt">-<wbr></wbr>-xform</span></span></a></td></tr><tr><td><span class="tocsublinknumber">5.1.5<tt>&nbsp;</tt></span><a href="#%28part._im~3a3m~3aplaces%29" class="tocsubseclink" data-pltdoc="x">Places and Garbage Collector Instances</a></td></tr><tr><td><span class="tocsublinknumber">5.2<tt>&nbsp;</tt></span><a href="#%28part._.Memory_.Functions%29" class="tocsubseclink" data-pltdoc="x">Memory Functions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="navsettop"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="…搜索手册…" title="输入搜索字符串以搜索手册" onkeypress="return DoSearchKey(event, this, &quot;7.0.0.18&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;…搜索手册…&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;…搜索手册…&quot;; }"/></form>&nbsp;&nbsp;<a href="../index.html" title="上至文档的顶层" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;7.0.0.18&quot;);">&#39030;&#23618;</a></span><span class="navright">&nbsp;&nbsp;<a href="im_values_types.html" title="后退至&quot;4 Values and Types&quot;" data-pltdoc="x">&larr; &#21069;&#19968;&#39029;</a>&nbsp;&nbsp;<a href="index.html" title="上至&quot;Inside: Racket C API&quot;" data-pltdoc="x">&#19978;&#19968;&#23618;</a>&nbsp;&nbsp;<a href="im_env.html" title="前进至&quot;6 Namespaces and Modules&quot;" data-pltdoc="x">&#21518;&#19968;&#39029; &rarr;</a></span>&nbsp;</div><h3 x-source-module="(lib &quot;scribblings/inside/inside.scrbl&quot;)" x-source-pkg="racket-doc" x-part-tag="&quot;im:memoryalloc&quot;">5<tt>&nbsp;</tt><a name="(part._im~3amemoryalloc)"></a><a name="(idx._(gentag._231._(lib._scribblings/inside/inside..scrbl)))"></a><a name="(idx._(gentag._232._(lib._scribblings/inside/inside..scrbl)))"></a>Memory Allocation</h3><p>Racket uses both <span class="stt">malloc</span> and allocation functions provided by a
garbage collector. Foreign-function and embedding/extension C code may
use either allocation method, keeping in mind that pointers to
garbage-collectable blocks in <span class="stt">malloc</span>ed memory are invisible
(i.e., such pointers will not prevent the block from being
garbage-collected).</p><p>Racket CGC uses a conservative garbage collector.  This garbage
collector normally only recognizes pointers to the beginning of
allocated objects. Thus, a pointer into the middle of a GC-allocated
string will normally not keep the string from being collected. The
exception to this rule is that pointers saved on the stack or in
registers may point to the middle of a collectable object.  Thus, it
is safe to loop over an array by incrementing a local pointer
variable.</p><p>Racket 3m uses a precise garbage collector that moves objects
during collection, in which case the C code must be instrumented to
expose local pointer bindings to the collector, and to provide tracing
procedures for (tagged) records containing pointers. This
instrumentation is described further in <a href="#%28part._im~3a3m%29" data-pltdoc="x">Cooperating with 3m</a>.</p><p>The basic collector allocation functions are:</p><ul><li><p><a href="#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a> &#8212;<wbr></wbr> Allocates collectable memory that may
contain pointers to collectable objects; for 3m, the memory must be
an array of pointers (though not necessarily to collectable
objects). The newly allocated memory is initially zeroed.</p></li><li><p><a href="#%28cpp._scheme_malloc_atomic%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_atomic</span></a> &#8212;<wbr></wbr> Allocates collectable memory
that does not contain pointers to collectable objects. If the memory
does contain pointers, they are invisible to the collector and will
not prevent an object from being collected. Newly allocated atomic
memory is not necessarily zeroed.</p><p>Atomic memory is used for strings or other blocks of memory which do
not contain pointers. Atomic memory can also be used to store
intentionally-hidden pointers.</p></li><li><p><a href="#%28cpp._scheme_malloc_tagged%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_tagged</span></a> &#8212;<wbr></wbr> Allocates collectable memory
that contains a mixture of pointers and atomic data. With the
conservative collector, this function is the same
as <a href="#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a>, but on 3m, the type tag stored at the
start of the block is used to determine the size and shape of the
object for future garbage collection (as described
in <a href="#%28part._im~3a3m%29" data-pltdoc="x">Cooperating with 3m</a>).</p></li><li><p><a href="#%28cpp._scheme_malloc_allow_interior%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a> &#8212;<wbr></wbr> Allocates an array of
pointers with special treatment by 3m: the array is never moved by
the garbage collector, references are allowed into the middle of the
block, and even-valued pointers to the middle of the block prevent
the block from being collected.  (Beware that the memory manager
treats any odd-valued pointer as a fixnum, even if it refers to the
middle of a block that allows interior pointers.) Use
this procedure sparingly, because small, non-moving objects are
handled less efficiently than movable objects by the 3m collector.
This procedure is the same as <a href="#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a> with the
conservative collector, but in the that case, having <span style="font-family: 楷体">only</span> a
pointer into the interior will not prevent the array from being
collected.</p></li><li><p><a href="#%28cpp._scheme_malloc_atomic_allow_interior%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_atomic_allow_interior</span></a> &#8212;<wbr></wbr> Like
<a href="#%28cpp._scheme_malloc_allow_interior%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a> for memory that does not
contain pointers.</p></li><li><p><a href="#%28cpp._scheme_malloc_uncollectable%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_uncollectable</span></a> &#8212;<wbr></wbr> Allocates
uncollectable memory that may contain pointers to collectable
objects. There is no way to free the memory. The newly allocated
memory is initially zeroed. This function is not available in 3m.</p></li></ul><p><a name="(idx._(gentag._233._(lib._scribblings/inside/inside..scrbl)))"></a>If a Racket extension
stores Racket pointers in a global or static variable, then that
variable must be registered with
<a href="#%28cpp._scheme_register_extension_global%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_extension_global</span></a>; this makes the pointer
visible to the garbage collector. Registered variables need not
contain a collectable pointer at all times (even with 3m, but the
variable must contain some pointer, possibly uncollectable, at all
times). Beware that static or global variables that are not
thread-specific (in the OS sense of &ldquo;thread&rdquo;) generally do not
work with multiple <a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=places.html%23%2528tech._place%2529&amp;version=7.0.0.18" class="techoutside Sq" data-pltdoc="x"><span class="techinside">place</span></a>s.</p><p>Registration is needed for the global and static variables of an
embedding program on most platforms, and registration is needed on all
platforms if the program calls <a href="#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> or
<a href="#%28cpp._scheme_set_stack_base%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_set_stack_base</span></a> with a non-zero first or second
(respectively) argument. Global and static variables containing
collectable pointers must be registered with
<a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a>. The <span class="stt">MZ_REGISTER_STATIC</span> macro
takes any variable name and registers it with
<a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a>. The <a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a>
function can be safely called even when it&rsquo;s not needed, but it must
not be called multiple times for a single memory address.  When using
<a href="#%28cpp._scheme_set_stack_base%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_set_stack_base</span></a> and when <a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=places.html%23%2528tech._place%2529&amp;version=7.0.0.18" class="techoutside Sq" data-pltdoc="x"><span class="techinside">place</span></a>s are enabled, then
<a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a> or <span class="stt">MZ_REGISTER_STATIC</span> normally
should be used only after <a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a>, since
<a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a> changes the allocation space as explained in
<a href="#%28part._im~3a3m~3aplaces%29" data-pltdoc="x">Places and Garbage Collector Instances</a>.</p><p>Collectable memory can be temporarily locked from collection by using
the reference-counting function <a href="#%28cpp._scheme_dont_gc_ptr%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_dont_gc_ptr</span></a>. On 3m,
such locking does not prevent the object from being moved.</p><p>Garbage collection can occur during any call into Racket or its
allocator, on anytime that Racket has control, except during functions
that are documented otherwise.  The predicate and accessor macros
listed in <a href="im_values_types.html#%28part._im~3astdtypes%29" data-pltdoc="x">Standard Types</a> never trigger a collection.</p><p>As described in <a href="#%28part._im~3a3m~3aplaces%29" data-pltdoc="x">Places and Garbage Collector Instances</a>, different <a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=places.html%23%2528tech._place%2529&amp;version=7.0.0.18" class="techoutside Sq" data-pltdoc="x"><span class="techinside">place</span></a>s
manage allocation separately. Movable memory should not be
communicated from one place to another, since the source place might
move the memory before it is used in the destination place.
Furthermore, allocated memory that contains pointers must not be
written in a <a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=places.html%23%2528tech._place%2529&amp;version=7.0.0.18" class="techoutside Sq" data-pltdoc="x"><span class="techinside">place</span></a> other than the one where it is allocated,
due to the place-specific implementation of a write barrier for
generational garbage collection. No write barrier is used for memory
that is allocated by <a href="#%28cpp._scheme_malloc_atomic_allow_interior%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_atomic_allow_interior</span></a> to
contain no pointers.</p><h4 x-source-module="(lib &quot;scribblings/inside/inside.scrbl&quot;)" x-source-pkg="racket-doc" x-part-tag="&quot;im:3m&quot;">5.1<tt>&nbsp;</tt><a name="(part._im~3a3m)"></a>Cooperating with 3m</h4><p>To allow 3m&rsquo;s precise collector to detect and update pointers during
garbage collection, all pointer values must be registered with the
collector, at least during the times that a collection may occur.  The
content of a word registered as a pointer must contain either
<span class="stt">NULL</span>, a pointer to the start of a collectable object, a pointer
into an object allocated by <a href="#%28cpp._scheme_malloc_allow_interior%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a>, a
pointer to an object currently allocated by another memory manager
(and therefore not into a block that is currently managed by the
collector), or a pointer to an odd-numbered address (e.g., a Racket
fixnum).</p><p>Pointers are registered in three different ways:</p><ul><li><p>Pointers in static variables should be registered with
<a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a> or <span class="stt">MZ_REGISTER_STATIC</span>.</p></li><li><p>Pointers in allocated memory are registered automatically when
they are in an array allocated with <a href="#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a>, etc.  When a
pointer resides in an object allocated with
<a href="#%28cpp._scheme_malloc_tagged%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_tagged</span></a>, etc.~the tag at the start of the object
identifiers the object&rsquo;s size and shape. Handling of tags is
described in <a href="#%28part._im~3a3m~3atagged%29" data-pltdoc="x">Tagged Objects</a>.</p></li><li><p>Local pointers (i.e., pointers on the stack or in registers)
must be registered through the <a href="#%28cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_DECL_REG</span></a>, etc<span class="Sendabbrev">.</span> macros
that are described in <a href="#%28part._im~3a3m~3astack%29" data-pltdoc="x">Local Pointers</a>.</p></li></ul><p>A pointer must never refer to the interior of an allocated object
(when a garbage collection is possible), unless the object was
allocated with <a href="#%28cpp._scheme_malloc_allow_interior%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a>. For this reason,
pointer arithmetic must usually be avoided, unless the variable
holding the generated pointer is <span class="stt">NULL</span>ed before a collection.</p><p><span style="font-weight: bold">IMPORTANT:</span> The <a href="im_values_types.html#%28cpp._.S.C.H.E.M.E_.S.Y.M_.V.A.L%29" class="RktStxLink" data-pltdoc="x"><span class="stt">SCHEME_SYM_VAL</span></a>,
<a href="im_values_types.html#%28cpp._.S.C.H.E.M.E_.K.E.Y.W.O.R.D_.V.A.L%29" class="RktStxLink" data-pltdoc="x"><span class="stt">SCHEME_KEYWORD_VAL</span></a>, <a href="im_values_types.html#%28cpp._.S.C.H.E.M.E_.V.E.C_.E.L.S%29" class="RktStxLink" data-pltdoc="x"><span class="stt">SCHEME_VEC_ELS</span></a>, and
<a href="Procedures.html#%28cpp._.S.C.H.E.M.E_.P.R.I.M_.C.L.O.S.U.R.E_.E.L.S%29" class="RktStxLink" data-pltdoc="x"><span class="stt">SCHEME_PRIM_CLOSURE_ELS</span></a> macros produce pointers into the middle
of their respective objects, so the results of these macros must not
be held during the time that a collection can occur. Incorrectly
retaining such a pointer can lead to a crash.</p><h5 x-source-module="(lib &quot;scribblings/inside/inside.scrbl&quot;)" x-source-pkg="racket-doc" x-part-tag="&quot;im:3m:tagged&quot;">5.1.1<tt>&nbsp;</tt><a name="(part._im~3a3m~3atagged)"></a>Tagged Objects</h5><p>As explained in <a href="im_values_types.html" data-pltdoc="x">Values and Types</a>, the <a href="im_values_types.html#%28cpp._scheme_make_type%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_make_type</span></a>
function can be used to obtain a new tag for a new type of object.
These new types are in relatively short supply for 3m; the maximum tag
is 512, and Racket itself uses nearly 300.</p><p>After allocating a new tag in 3m (and before creating instances of the
tag), a <span style="font-family: 楷体">size procedure</span>, a <span style="font-family: 楷体">mark procedure</span>, and a
<span style="font-family: 楷体">fixup procedure</span> must be installed for the tag using
<a href="#%28cpp._.G.C_register_traversers%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_register_traversers</span></a>. A type tag and its associated GC
procedures apply to all <a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=places.html%23%2528tech._place%2529&amp;version=7.0.0.18" class="techoutside Sq" data-pltdoc="x"><span class="techinside">place</span></a>s, even though specific allocated
objects are confined to a particular <a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=places.html%23%2528tech._place%2529&amp;version=7.0.0.18" class="techoutside Sq" data-pltdoc="x"><span class="techinside">place</span></a>.</p><p>A size procedure simply takes a pointer to an object with the tag and
returns its size in words (not bytes). The <span class="stt">gcBYTES_TO_WORDS</span>
macro converts a byte count to a word count.</p><p>A mark procedure is used to trace references among objects. The
procedure takes a pointer to an object, and it should apply the
<span class="stt">gcMARK</span> macro to every pointer within the object. The mark
procedure should return the same result as the size procedure.</p><p>A fixup procedure is potentially used to update references to objects
that have moved, although the mark procedure may have moved objects
and updated references already. The fixup procedure takes a pointer to
an object, and it should apply the <span class="stt">gcFIXUP</span> macro to every
pointer within the object. The fixup procedure should return the same
result as the size procedure.</p><p>Depending on the collector&rsquo;s implementation, the <span class="stt">gcMARK</span> and/or
<span class="stt">gcFIXUP</span> macros may take take the address of their arguments, and
the fixup procedure might not be used. For example, the collector may
only use the mark procedure and not actually move the object. Or it
may use mark to move objects at the same time. To dereference an
object pointer during a mark or fixup procedure, use <a href="#%28cpp._.G.C_resolve%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_resolve</span></a>
to convert a potentially old address to the location where the object
has been moved. To dereference an object pointer during a fixup procedure, use
<a href="#%28cpp._.G.C_fixup_self%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_fixup_self</span></a> to convert the address passed to the procedure to
refer to the potentially moved object.</p><p>When allocating a tagged object in 3m, the tag must be installed
immediately after the object is allocated&#8212;<wbr></wbr>or, at least, before the
next possible collection.</p><h5 x-source-module="(lib &quot;scribblings/inside/inside.scrbl&quot;)" x-source-pkg="racket-doc" x-part-tag="&quot;im:3m:stack&quot;">5.1.2<tt>&nbsp;</tt><a name="(part._im~3a3m~3astack)"></a>Local Pointers</h5><p>The 3m collector needs to know the address of every local or temporary
pointer within a function call at any point when a collection can be
triggered. Beware that nested function calls can hide temporary
pointers; for example, in</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(scheme_make_pair(scheme_true, scheme_false),</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(scheme_false, scheme_true))</span></p></td></tr></table></p><p>the result from one <a href="im_values_types.html#%28cpp._scheme_make_pair%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_make_pair</span></a> call is on the stack or in
a register during the other call to <a href="im_values_types.html#%28cpp._scheme_make_pair%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_make_pair</span></a>; this
pointer must be exposed to the garbage collection and made subject to
update. Simply changing the code to</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp = scheme_make_pair(scheme_true, scheme_false);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(tmp,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(scheme_false, scheme_true))</span></p></td></tr></table></p><p>does not expose all pointers, since <span class="stt">tmp</span> must be evaluated before
the second call to <a href="im_values_types.html#%28cpp._scheme_make_pair%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_make_pair</span></a>. In general, the above code
must be converted to the form</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_make_pair(scheme_true, scheme_false);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp2 = scheme_make_pair(scheme_true, scheme_false);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">scheme_make_pair(tmp1, tmp2);</span></p></td></tr></table></p><p>and this is converted form must be instrumented to register <span class="stt">tmp1</span>
and <span class="stt">tmp2</span>. The final result might be</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp1 = NULL, *tmp2 = NULL, *result;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, tmp1);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(1, tmp2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_make_pair(scheme_true, scheme_false);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp2 = scheme_make_pair(scheme_true, scheme_false);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">result = scheme_make_pair(tmp1, tmp2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return result;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>Notice that <span class="stt">result</span> is not registered above. The
<a name="(cpp._.M.Z_.G.C_.U.N.R.E.G)"></a><a name="(idx._(gentag._234._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.M.Z_.G.C_.U.N.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> macro cannot trigger a garbage collection, so the
<span class="stt">result</span> variable is never live during a potential
collection. Note also that <span class="stt">tmp1</span> and <span class="stt">tmp2</span> are initialized
with <span class="stt">NULL</span>, so that they always contain a pointer whenever a
collection is possible.</p><p>The <a name="(cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G)"></a><a name="(idx._(gentag._235._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_DECL_REG</span></a> macro expands to a local-variable
declaration to hold information for the garbage collector. The
argument is the number of slots to provide for
registration. Registering a simple pointer requires a single slot,
whereas registering an array of pointers requires three slots. For
example, to register a pointer <span class="stt">tmp</span> and an array of 10
<span class="stt">char*</span>s:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp1 = NULL;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">char *a[10];</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int i;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(4);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_ARRAY_VAR_IN_REG(0, a, 10);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(3, tmp1);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">/* Clear a before a potential GC: */</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">for (i = 0; i &lt; 10; i++) a[i] = NULL;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">f(a);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>The <a name="(cpp._.M.Z_.G.C_.A.R.R.A.Y_.V.A.R_.I.N_.R.E.G)"></a><a name="(idx._(gentag._236._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.M.Z_.G.C_.A.R.R.A.Y_.V.A.R_.I.N_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_ARRAY_VAR_IN_REG</span></a> macro registers a local array given
a starting slot, the array variable, and an array size. The
<a name="(cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G)"></a><a name="(idx._(gentag._237._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_VAR_IN_REG</span></a> macro takes a slot and simple pointer variable. A
local variable or array must not be registered multiple times.</p><p>In the above example, the first argument to <a href="#%28cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_VAR_IN_REG</span></a> is
<span class="stt">3</span> because the information for <span class="stt">a</span> uses the first three
slots. Even if <span class="stt">a</span> is not used after the call to <span class="stt">f</span>, <span class="stt">a</span>
must be registered with the collector during the entire call to
<span class="stt">f</span>, because <span class="stt">f</span> presumably uses <span class="stt">a</span> until it returns.</p><p>The name used for a variable need not be immediate. Structure members
can be supplied as well:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">struct { void *s; int v; void *t; } x = {NULL, 0, NULL};</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, x.s);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, x.t);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">...</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>In general, the only constraint on the second argument to
<a href="#%28cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_VAR_IN_REG</span></a> or <a href="#%28cpp._.M.Z_.G.C_.A.R.R.A.Y_.V.A.R_.I.N_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_ARRAY_VAR_IN_REG</span></a> is that
<span class="stt">&amp;</span> must produce the relevant address, and that address must be on
the stack.</p><p>Pointer information is not actually registered with the collector
until the <a name="(cpp._.M.Z_.G.C_.R.E.G)"></a><a name="(idx._(gentag._238._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.M.Z_.G.C_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_REG</span></a> macro is used. The <a href="#%28cpp._.M.Z_.G.C_.U.N.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> macro
de-registers the information. Each call to <a href="#%28cpp._.M.Z_.G.C_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_REG</span></a> must be
balanced by one call to <a href="#%28cpp._.M.Z_.G.C_.U.N.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a>.</p><p>Pointer information need not be initialized with
<a href="#%28cpp._.M.Z_.G.C_.V.A.R_.I.N_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_VAR_IN_REG</span></a> and <a href="#%28cpp._.M.Z_.G.C_.A.R.R.A.Y_.V.A.R_.I.N_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_ARRAY_VAR_IN_REG</span></a> before
calling <a href="#%28cpp._.M.Z_.G.C_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_REG</span></a>, and the set of registered pointers can change
at any time&#8212;<wbr></wbr>as long as all relevant pointers are registered when a
collection might occur. The following example recycles slots and
completely de-registers information when no pointers are relevant. The
example also illustrates how <a href="#%28cpp._.M.Z_.G.C_.U.N.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> is not needed when
control escapes from the function, such as when
<a href="exceptions.html#%28cpp._scheme_signal_error%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_signal_error</span></a> escapes.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp1 = NULL, *tmp2 = NULL;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">mzchar *a, *b;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, tmp1);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(1, tmp2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_make_utf8_string("foo");</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp2 = scheme_make_utf8_string("bar");</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_append_char_string(tmp1, tmp2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if (SCHEME_FALSEP(tmp1))</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_signal_error("shouldn't happen!");</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">a = SCHEME_CHAR_VAL(tmp1);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, a);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp2 = scheme_make_pair(scheme_read_bignum(a, 0, 10), tmp2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">if (SCHEME_INTP(tmp2)) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">return 0;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">tmp1 = scheme_make_pair(scheme_read_bignum(a, 0, 8), tmp2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return tmp1;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>A <a href="#%28cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_DECL_REG</span></a> can be used in a nested block to hold
declarations for the block&rsquo;s variables. In that case, the nested
<a href="#%28cpp._.M.Z_.G.C_.D.E.C.L_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_DECL_REG</span></a> must have its own <a href="#%28cpp._.M.Z_.G.C_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_REG</span></a> and
<a href="#%28cpp._.M.Z_.G.C_.U.N.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> calls.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *accum = NULL;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(1);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, accum);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(scheme_true, scheme_null);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp = NULL;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(1);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, tmp);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">tmp = scheme_make_pair(scheme_true, scheme_false);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(tmp, accum);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(scheme_true, accum);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return accum;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>Variables declared in a local block can also be registered together
with variables from an enclosing block, but the local-block variable
must be unregistered before it goes out of scope. The
<a name="(cpp._.M.Z_.G.C_.N.O_.V.A.R_.I.N_.R.E.G)"></a><a name="(idx._(gentag._239._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.M.Z_.G.C_.N.O_.V.A.R_.I.N_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_NO_VAR_IN_REG</span></a> macro can be used to unregister a variable
or to initialize a slot as having no variable.</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">Scheme_Object *accum = NULL;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_DECL_REG(2);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(0, accum);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_NO_VAR_IN_REG(1);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_REG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(scheme_true, scheme_null);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Scheme_Object *tmp = NULL;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_VAR_IN_REG(1, tmp);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">tmp = scheme_make_pair(scheme_true, scheme_false);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(tmp, accum);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">MZ_GC_NO_VAR_IN_REG(1);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">accum = scheme_make_pair(scheme_true, accum);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">MZ_GC_UNREG();</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return accum;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>The <span class="stt">MZ_GC_</span> macros all expand to nothing when <span class="stt">MZ_PRECISE_GC</span>
is not defined, so the macros can be placed into code to be compiled
for both conservative and precise collection.</p><p>The <a href="#%28cpp._.M.Z_.G.C_.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_REG</span></a> and <a href="#%28cpp._.M.Z_.G.C_.U.N.R.E.G%29" class="RktStxLink" data-pltdoc="x"><span class="stt">MZ_GC_UNREG</span></a> macros must never be
used in an OS thread other than Racket&rsquo;s thread.</p><h5 x-source-module="(lib &quot;scribblings/inside/inside.scrbl&quot;)" x-source-pkg="racket-doc" x-part-tag="&quot;im:3m:mzc&quot;">5.1.3<tt>&nbsp;</tt><a name="(part._im~3a3m~3amzc)"></a>Local Pointers and <span class="stt">raco ctool</span> <span class="nobreak"><span class="stt">--xform</span></span></h5><p>When <span class="stt">raco ctool</span> is run with the <span class="nobreak"><span class="stt">--xform</span></span> flag and a source C program,
it produces a C program that is instrumented in the way described in
the previous section (but with a slightly different set of macros).
For each input file <span class="stt">"<span style="font-family: 楷体">name</span>.c"</span>, the transformed output
is <span class="stt">"<span style="font-family: 楷体">name</span>.3m.c"</span>.</p><p>The <span class="nobreak"><span class="stt">--xform</span></span> mode for <span class="stt">raco ctool</span> does not change allocation calls,
nor does it generate size, mark, or fixup procedures. It merely
converts the code to register local pointers.</p><p>Furthermore, the <span class="nobreak"><span class="stt">--xform</span></span> mode for <span class="stt">raco ctool</span> does not handle all of
C. It&rsquo;s ability to rearrange compound expressions is particularly
limited, because <span class="nobreak"><span class="stt">--xform</span></span> merely converts expression text
heuristically instead of parsing C. A future version of the tool will
correct such problems. For now, <span class="stt">raco ctool</span> in <span class="nobreak"><span class="stt">--xform</span></span> mode attempts
to provide reasonable error messages when it is unable to convert a
program, but beware that it can miss cases. To an even more limited
degree, <span class="nobreak"><span class="stt">--xform</span></span> can work on C++ code. Inspect the output of
<span class="nobreak"><span class="stt">--xform</span></span> mode to ensure that your code is correctly instrumented.</p><p>Some specific limitations:</p><ul><li><p>The body of a <span class="stt">for</span>, <span class="stt">while</span>, or <span class="stt">do</span> loop must be
surrounded with curly braces.  (A conversion error is normally
reported, otherwise.)</p></li><li><p>Function calls may not appear on the right-hand side of an
assignment within a declaration block.  (A conversion error is
normally reported if such an assignment is discovered.)</p></li><li><p>Multiple function calls in <span class="stt">... ? ... : ...</span> cannot be
lifted. (A conversion error is normally reported, otherwise.)</p></li><li><p>In an assignment, the left-hand side must be a local or static
variable, not a field selection, pointer dereference, etc. (A
conversion error is normally reported, otherwise.)</p></li><li><p>The conversion assumes that all function calls use an immediate
name for a function, as opposed to a compound expression as
in <span class="stt">s-&gt;f()</span>. The function name need not be a top-level
function name, but it must be bound either as an argument or
local variable with the form <span style="font-family: 楷体">type</span><span class="stt"> </span><span style="font-family: 楷体">id</span>; the
syntax <span style="font-family: 楷体">ret_type</span><span class="stt"> (*</span><span style="font-family: 楷体">id</span><span class="stt">)(...)</span> is not
recognized, so bind the function type to a simple name
with <span class="stt">typedef</span>, first: <span class="stt">typedef </span><span style="font-family: 楷体">ret_type</span><span class="stt">
</span><span class="stt">(*</span><span style="font-family: 楷体">type</span><span class="stt">)(...); .... </span><span style="font-family: 楷体">type</span><span class="stt"> </span><span style="font-family: 楷体">id</span>.</p></li><li><p>Arrays and structs must be passed by address, only.</p></li><li><p>GC-triggering code must not appear in system headers.</p></li><li><p>Pointer-comparison expressions are not handled correctly when
either of the compared expressions includes a function call.
For example, <span class="stt">a() == b()</span> is not converted correctly when
<span class="stt">a</span> and <span class="stt">b</span> produce pointer values.</p></li><li><p>Passing the address of a local pointer to a function works only
when the pointer variable remains live after the function call.</p></li><li><p>A <span class="stt">return;</span> form can get converted to <span class="stt">{ </span><span style="font-family: 楷体">stmt</span><span class="stt">; return; };</span>, which can break an <span class="stt">if (...) return; else
...</span> pattern.</p></li><li><p>Local instances of union types are generally not supported.</p></li><li><p>Pointer arithmetic cannot be converted away, and is instead
reported as an error.</p></li></ul><h5 x-source-module="(lib &quot;scribblings/inside/inside.scrbl&quot;)" x-source-pkg="racket-doc" x-part-tag="&quot;im:3m:macros&quot;">5.1.4<tt>&nbsp;</tt><a name="(part._im~3a3m~3amacros)"></a>Guiding <span class="stt">raco ctool</span> <span class="nobreak"><span class="stt">--xform</span></span></h5><p>The following macros can be used (with care!) to navigate
<span class="nobreak"><span class="stt">--xform</span></span> around code that it cannot handle:</p><ul><li><p><a name="(cpp._.X.F.O.R.M_.S.T.A.R.T_.S.K.I.P)"></a><a name="(idx._(gentag._240._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.S.T.A.R.T_.S.K.I.P%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_START_SKIP</span></a> and <a name="(cpp._.X.F.O.R.M_.E.N.D_.S.K.I.P)"></a><a name="(idx._(gentag._241._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.E.N.D_.S.K.I.P%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_END_SKIP</span></a>: code
  between these two statements is ignored by the transform tool,
  except to tokenize it.</p><p>Example:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int foo(int c, ...) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int r = 0;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">XFORM_START_SKIP;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/* va plays strange tricks that confuse xform */</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">va_list args;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">va_start(args, c);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">while (c--) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">r += va_arg(args, int);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">XFORM_END_SKIP;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return r;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>These macros can also be used at the top level, outside of any
 function.  Since they have to be terminated by a semi-colon, however,
 top-level uses usually must be wrapped with <span class="stt">#ifdef
MZ_PRECISE_GC</span> and <span class="stt">#endif</span>; a semi-colon by itself at the
 top level is not legal in C.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.S.K.I.P_.P.R.O.C)"></a><a name="(idx._(gentag._242._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.S.K.I.P_.P.R.O.C%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_SKIP_PROC</span></a>: annotate a function so that its body
    is skipped in the same way as bracketing it with
    <a href="#%28cpp._.X.F.O.R.M_.S.T.A.R.T_.S.K.I.P%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_START_SKIP</span></a> and <a href="#%28cpp._.X.F.O.R.M_.E.N.D_.S.K.I.P%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_END_SKIP</span></a>.</p><p>Example:</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int foo(int c, ...) XFORM_SKIP_PROC {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></li><li><p><a name="(cpp._.X.F.O.R.M_.H.I.D.E_.E.X.P.R)"></a><a name="(idx._(gentag._243._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.H.I.D.E_.E.X.P.R%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_HIDE_EXPR</span></a>: a macro that takes wraps an expression to
disable processing of the expression.</p><p>Example:</p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int foo(int c, ...) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">int r = 0;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">{</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">/* va plays strange tricks that confuse xform */</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">XFORM_CAN_IGNORE va_list args; /* See below */</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">XFORM_HIDE_EXPR(va_start(args, c));</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">while (c--) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">r += XFORM_HIDE_EXPR(va_arg(args, int));</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;</span><span class="stt">return r;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></li><li><p><a name="(cpp._.X.F.O.R.M_.C.A.N_.I.G.N.O.R.E)"></a><a name="(idx._(gentag._244._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.C.A.N_.I.G.N.O.R.E%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_CAN_IGNORE</span></a>: a macro that acts like a type
modifier (must appear first) to indicate that a declared variable
can be treated as atomic. See above for an example.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.S.T.A.R.T_.S.U.S.P.E.N.D)"></a><a name="(idx._(gentag._245._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.S.T.A.R.T_.S.U.S.P.E.N.D%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_START_SUSPEND</span></a> and <a name="(cpp._.X.F.O.R.M_.E.N.D_.S.U.S.P.E.N.D)"></a><a name="(idx._(gentag._246._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.E.N.D_.S.U.S.P.E.N.D%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_END_SUSPEND</span></a>: for
use at the top level (outside of any function definition), and
similar to <a href="#%28cpp._.X.F.O.R.M_.S.T.A.R.T_.S.K.I.P%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_START_SKIP</span></a> and <a href="#%28cpp._.X.F.O.R.M_.E.N.D_.S.K.I.P%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_END_SKIP</span></a> in
that function and class bodies are not transformed. Type and
prototype information is still collected for use by later
transformations, however. These forms must be terminated by a
semi-colon.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.S.T.A.R.T_.T.R.U.S.T_.A.R.I.T.H)"></a><a name="(idx._(gentag._247._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.S.T.A.R.T_.T.R.U.S.T_.A.R.I.T.H%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_START_TRUST_ARITH</span></a> and
<a name="(cpp._.X.F.O.R.M_.E.N.D_.T.R.U.S.T_.A.R.I.T.H)"></a><a name="(idx._(gentag._248._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.E.N.D_.T.R.U.S.T_.A.R.I.T.H%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_END_TRUST_ARITH</span></a>: for use at the top level (outside
of any function definition) to disable warnings about pointer
arithmetic. Use only when you&rsquo;re absolutely certain that the garbage
collector cannot be pointers offset into the middle of a collectable
object. These forms must be terminated by a semi-colon.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.T.R.U.S.T_.P.L.U.S)"></a><a name="(idx._(gentag._249._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.T.R.U.S.T_.P.L.U.S%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_TRUST_PLUS</span></a>: a replacement for <span class="stt">+</span> that does
not trigger pointer-arithmetic warnings. Use with care.</p></li><li><p><a name="(cpp._.X.F.O.R.M_.T.R.U.S.T_.M.I.N.U.S)"></a><a name="(idx._(gentag._250._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.X.F.O.R.M_.T.R.U.S.T_.M.I.N.U.S%29" class="RktStxLink" data-pltdoc="x"><span class="stt">XFORM_TRUST_MINUS</span></a>: a replacement for <span class="stt">-</span> that does
not trigger pointer-arithmetic warnings. Use with care.</p></li></ul><h5 x-source-module="(lib &quot;scribblings/inside/inside.scrbl&quot;)" x-source-pkg="racket-doc" x-part-tag="&quot;im:3m:places&quot;">5.1.5<tt>&nbsp;</tt><a name="(part._im~3a3m~3aplaces)"></a>Places and Garbage Collector Instances</h5><p>When <a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=places.html%23%2528tech._place%2529&amp;version=7.0.0.18" class="techoutside Sq" data-pltdoc="x"><span class="techinside">place</span></a>s are enabled, then a single process can have
multiple instances of the garbage collector in the same process. Each
<a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=places.html%23%2528tech._place%2529&amp;version=7.0.0.18" class="techoutside Sq" data-pltdoc="x"><span class="techinside">place</span></a> allocates using its own collector, and no place is
allowed to hold a reference to memory that is allocated by another
place. In addition, a <a name="(tech._master)"></a><span style="font-family: 楷体">master</span> garbage collector instance
holds values that are shared among places; different places can refer
to memory that is allocated by the <a href="#%28tech._master%29" class="techoutside" data-pltdoc="x"><span class="techinside">master</span></a> garbage collector,
but the <a href="#%28tech._master%29" class="techoutside" data-pltdoc="x"><span class="techinside">master</span></a> still cannot reference memory allocated by
place-specific garbage collectors.</p><p>Calling <a href="#%28cpp._scheme_main_stack_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_stack_setup</span></a> creates the <a href="#%28tech._master%29" class="techoutside" data-pltdoc="x"><span class="techinside">master</span></a>
garbage collector, and allocation uses that collector until
<a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a> returns, at which point the initial place&rsquo;s
garbage collector is in effect. Using <a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a> or
<span class="stt">MZ_REGISTER_STATIC</span> before calling <a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a>
registers an address that should be used to hold only values allocated
before <a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a> is called. More typically,
<a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a> and <span class="stt">MZ_REGISTER_STATIC</span> are used
only after <a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a> returns. Using
<a href="#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> calls <a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a> automatically, in
which case there is no opportunity to use <a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a>
or <span class="stt">MZ_REGISTER_STATIC</span> too early.</p><h4 x-source-module="(lib &quot;scribblings/inside/inside.scrbl&quot;)" x-source-pkg="racket-doc" x-part-tag="&quot;Memory_Functions&quot;">5.2<tt>&nbsp;</tt><a name="(part._.Memory_.Functions)"></a>Memory Functions</h4><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc)"></a><a name="(idx._(gentag._251._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates <span style="font-family: 楷体">n</span> bytes of collectable memory, initially filled with
zeros. In 3m, the allocated object is treated as an array of
pointers.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_atomic)"></a><a name="(idx._(gentag._252._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_atomic%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_atomic</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates <span style="font-family: 楷体">n</span> bytes of collectable memory containing no pointers
visible to the garbage collector. The object is <span style="font-family: 楷体">not</span>
initialized to zeros.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_uncollectable)"></a><a name="(idx._(gentag._253._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_uncollectable%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_uncollectable</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Non-3m, only. Allocates <span style="font-family: 楷体">n</span> bytes of uncollectable memory.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_eternal)"></a><a name="(idx._(gentag._254._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_eternal%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_eternal</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates uncollectable atomic memory. This function is equivalent to
 <span class="stt">malloc</span>, except that the memory cannot be freed.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_calloc)"></a><a name="(idx._(gentag._255._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_calloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_calloc</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">num</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates <span style="font-family: 楷体">num</span> * <span style="font-family: 楷体">size</span> bytes of memory using <a href="#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_tagged)"></a><a name="(idx._(gentag._256._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_tagged%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_tagged</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a>, but in 3m, the type tag determines how the
 garbage collector traverses the object; see <a href="" data-pltdoc="x">Memory Allocation</a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_allow_interior)"></a><a name="(idx._(gentag._257._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_allow_interior%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_allow_interior</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a>, but in 3m, the object never moves, and pointers are allowed to
 reference the middle of the object; see <a href="" data-pltdoc="x">Memory Allocation</a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_atomic_allow_interior)"></a><a name="(idx._(gentag._258._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_atomic_allow_interior%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_atomic_allow_interior</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#%28cpp._scheme_malloc_atomic%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_atomic</span></a>, but in 3m, the object never moves, and pointers are allowed to
 reference the middle of the object; see <a href="" data-pltdoc="x">Memory Allocation</a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_stubborn)"></a><a name="(idx._(gentag._259._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_stubborn%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_stubborn</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">n</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">An obsolete variant of <a href="#%28cpp._scheme_malloc%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc</span></a>, where
 <a href="#%28cpp._scheme_end_stubborn_change%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_end_stubborn_change</span></a> can be called on the allocated
 pointer when no further changes will be made to the allocated
 memory. Stubborn allocation is potentially useful as a hint for
 generational collection, but the hint is normally ignored and unlikely
 to be used more in future version.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_end_stubborn_change)"></a><a name="(idx._(gentag._260._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_end_stubborn_change%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_end_stubborn_change</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Declares the end of changes to the memory at <span style="font-family: 楷体">p</span> as allocated via
<a href="#%28cpp._scheme_malloc_stubborn%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_stubborn</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_strdup)"></a><a name="(idx._(gentag._261._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_strdup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_strdup</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">str</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Copies the null-terminated string <span style="font-family: 楷体">str</span>; the copy is collectable.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">char*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_strdup_eternal)"></a><a name="(idx._(gentag._262._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_strdup_eternal%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_strdup_eternal</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">char*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">str</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Copies the null-terminated string <span style="font-family: 楷体">str</span>; the copy will never be freed.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_fail_ok)"></a><a name="(idx._(gentag._263._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_fail_ok%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_fail_ok</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void *(*)(size_t)</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">mallocf</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">size_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Attempts to allocate <span style="font-family: 楷体">size</span> bytes using <span style="font-family: 楷体">mallocf</span>. If the
allocation fails, the <span class="RktSym">exn:misc:out-of-memory</span> exception is
raised.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void**</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_immobile_box)"></a><a name="(idx._(gentag._264._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_immobile_box%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_immobile_box</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates memory that is not garbage-collected and that does not move
(even with 3m), but whose first word contains a pointer to a
collectable object. The box is initialized with <span style="font-family: 楷体">p</span>, but the value
can be changed at any time. An immobile box must be explicitly freed
using <a href="#%28cpp._scheme_free_immobile_box%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_free_immobile_box</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_free_immobile_box)"></a><a name="(idx._(gentag._265._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_free_immobile_box%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_free_immobile_box</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void**</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">b</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Frees an immobile box allocated with <a href="#%28cpp._scheme_malloc_immobile_box%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_immobile_box</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_malloc_code)"></a><a name="(idx._(gentag._266._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_malloc_code%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_code</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">intptr_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Allocates non-collectable memory to hold executable machine code. Use
this function instead of <span class="stt">malloc</span> to ensure that the allocated
memory has &ldquo;execute&rdquo; permissions. Use <a href="#%28cpp._scheme_free_code%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_free_code</span></a> to free
memory allocated by this function.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_free_code)"></a><a name="(idx._(gentag._267._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_free_code%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_free_code</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Frees memory allocated with <a href="#%28cpp._scheme_malloc_code%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_malloc_code</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_register_extension_global)"></a><a name="(idx._(gentag._268._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_register_extension_global%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_extension_global</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">ptr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">intptr_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Registers an extension&rsquo;s global variable that can contain Racket
 pointers (for the current <a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=places.html%23%2528tech._place%2529&amp;version=7.0.0.18" class="techoutside Sq" data-pltdoc="x"><span class="techinside">place</span></a>). The address of the global
 is given in <span style="font-family: 楷体">ptr</span>, and its
 size in bytes in <span style="font-family: 楷体">size</span>.</div></p><p>In addition to global variables, this
 function can be used to register any permanent memory that the
 collector would otherwise treat as atomic. A garbage collection can
 occur during the registration.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_main_setup)"></a><a name="(idx._(gentag._269._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">no_auto_statics</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Env_Main</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">main</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">argc</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">char**</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">argv</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Initializes the GC stack base, creates the initial namespace by
calling <a href="Evaluation.html#%28cpp._scheme_basic_env%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_basic_env</span></a>, and then calls <span style="font-family: 楷体">main</span> with the
namespace, <span style="font-family: 楷体">argc</span>, and <span style="font-family: 楷体">argv</span>. (The <span style="font-family: 楷体">argc</span> and <span style="font-family: 楷体">argv</span>
are just passed on to <span style="font-family: 楷体">main</span>, and are not inspected in any way.)</div></p><p>The <span class="stt">Scheme_Env_Main</span> type is defined as follows:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">typedef int (*Scheme_Env_Main)(Scheme_Env *env,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">int argc, char **argv);</span></p></td></tr></table></p><p>The result of <span style="font-family: 楷体">main</span> is the result of <a href="#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a>.</p><p>If <span style="font-family: 楷体">no_auto_statics</span> is non-zero, then static variables must be
explicitly registered with the garbage collector; see
<a href="" data-pltdoc="x">Memory Allocation</a> for more information.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">int</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_main_stack_setup)"></a><a name="(idx._(gentag._270._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_main_stack_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_stack_setup</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">no_auto_statics</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Nested_Main</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">main</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">A more primitive variant of <a href="#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> that initializes
the GC stack base but does not create the initial namespace (so an
embedding application can perform other operations that involve
garbage-collected data before creating a namespace).</div></p><p>The <span style="font-family: 楷体">data</span> argument is passed through to <span style="font-family: 楷体">main</span>, where the
<span class="stt">Scheme_Nested_Main</span> type is defined as follows:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">typedef int (*Scheme_Nested_Main)(void *data);</span></p></td></tr></table></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_set_stack_base)"></a><a name="(idx._(gentag._271._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_set_stack_base%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_set_stack_base</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">stack_addr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">no_auto_statics</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Overrides the GC&rsquo;s auto-determined stack base, and/or disables the
 GC&rsquo;s automatic traversal of global and static variables. If
 <span style="font-family: 楷体">stack_addr</span> is <span class="stt">NULL</span>, the stack base determined by the GC
 is used. Otherwise, it should be the &ldquo;deepest&rdquo; memory address on
 the stack where a collectable pointer might be stored. This function
 should be called only once, and before any other <span class="stt">scheme_</span>
 function is called, but only with CGC and when future and places are
 disabled. The function never triggers a garbage collection.</div></p><p>Example:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">int main(int argc, char **argv) {</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">int dummy;</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">scheme_set_stack_base(&amp;dummy, 0);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">real_main(argc, argv); /* calls scheme_basic_env(), etc. */</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">}</span></p></td></tr></table></p><p>On 3m, the above code does not quite work, because <span style="font-family: 楷体">stack_addr</span>
must be the beginning or end of a local-frame registration. Worse, in
CGC or 3m, if <span class="stt">real_main</span> is declared <span class="stt">static</span>, the compiler
may inline it and place variables containing collectable values deeper
in the stack than <span class="stt">dummy</span>. To avoid these problems, use
<a href="#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> or <a href="#%28cpp._scheme_main_stack_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_stack_setup</span></a>, instead.</p><p>The above code also may not work when future and/or places are enabled
in Racket, because <a href="#%28cpp._scheme_set_stack_base%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_set_stack_base</span></a> does not initialize
Racket&rsquo;s thread-local variables. Again, use <a href="#%28cpp._scheme_main_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_setup</span></a> or
<a href="#%28cpp._scheme_main_stack_setup%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_main_stack_setup</span></a> to avoid the problem.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_set_stack_bounds)"></a><a name="(idx._(gentag._272._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_set_stack_bounds%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_set_stack_bounds</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">stack_addr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">stack_end</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">no_auto_statics</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#%28cpp._scheme_set_stack_base%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_set_stack_base</span></a>, except for the extra
<span style="font-family: 楷体">stack_end</span> argument. If <span style="font-family: 楷体">stack_end</span> is non-<span class="stt">NULL</span>, then
it corresponds to a point of C-stack growth after which Racket
should attempt to handle stack overflow. The <span style="font-family: 楷体">stack_end</span> argument
should not correspond to the actual stack end, since detecting stack
overflow may take a few frames, and since handling stack overflow
requires a few frames.</div></p><p>If <span style="font-family: 楷体">stack_end</span> is <span class="stt">NULL</span>, then the stack end is computed
automatically: the stack size assumed to be the limit reported by
<span class="stt">getrlimit</span> on Unix and Mac OS, or it is assumed to be the
stack reservation of the executable (or 1 MB if parsing the
executable fails) on Windows; if this size is greater than 8 MB, then 8 MB is
assumed, instead; the size is decremented by 50000 bytes
(64-bit Windows: 100000 bytes) to cover a
large margin of error; finally, the size is subtracted from (for
stacks that grow down) or added to (for stacks that grow up) the stack
base in <span style="font-family: 楷体">stack_addr</span> or the automatically computed stack
base. Note that the 50000-byte margin of error is assumed to cover the
difference between the actual stack start and the reported stack base,
in addition to the margin needed for detecting and handling stack
overflow.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_register_tls_space)"></a><a name="(idx._(gentag._273._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_register_tls_space%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_tls_space</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">ptr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">tls_index</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">For Windows, registers <span style="font-family: 楷体">ptr</span> as the address of a
 thread-local pointer variable that is declared in the main
 executable. The variable&rsquo;s storage will be used to implement
 thread-local storage within the Racket run-time. See
 <a href="embedding.html" data-pltdoc="x">Embedding into a Program</a>.</div></p><p>The <span style="font-family: 楷体">tls_index</span> argument must be <span class="stt">0</span>. It is currently
 ignored, but a future version may use the argument to allow
 declaration of the thread-local variable in a dynamically linked
 DLL.</p><p class="SHistory">&#20462;&#25913;&#20110;6.3&#29256;&#26412;&#65306;Changed from available only on 32-bit Windows
to available on all Windows variants.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_register_static)"></a><a name="(idx._(gentag._274._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">ptr</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">intptr_t</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">size</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#%28cpp._scheme_register_extension_global%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_extension_global</span></a>, for use in embedding
 applications in situations where the collector does not automatically
 find static variables (i.e., when <a href="#%28cpp._scheme_set_stack_base%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_set_stack_base</span></a> has
 been called with a non-zero second argument).</div></p><p>The macro <span class="stt">MZ_REGISTER_STATIC</span> can be used directly on a static
 variable. It expands to a comment if statics need not be registered,
 and a call to <a href="#%28cpp._scheme_register_static%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_static</span></a> (with the address of the
 static variable) otherwise.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_weak_reference)"></a><a name="(idx._(gentag._275._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_weak_reference%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_weak_reference</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void**</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Registers the pointer <span style="font-family: 楷体">*p</span> as a weak pointer; when no other
(non-weak) pointers reference the same memory as <span style="font-family: 楷体">*p</span> references,
then <span style="font-family: 楷体">*p</span> will be set to <span class="stt">NULL</span> by the garbage collector. The
value in <span style="font-family: 楷体">*p</span> may change, but the pointer remains weak with
respect to the value of <span style="font-family: 楷体">*p</span> at the time <span style="font-family: 楷体">p</span> was registered.</div></p><p>This function is not available in 3m.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_weak_reference_indirect)"></a><a name="(idx._(gentag._276._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_weak_reference_indirect%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_weak_reference_indirect</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void**</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">v</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#%28cpp._scheme_weak_reference%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_weak_reference</span></a>, but <span style="font-family: 楷体">*p</span> is set to <span class="stt">NULL</span>
(regardless of its prior value) when there are no references to <span style="font-family: 楷体">v</span>.</div></p><p>This function is not available in 3m.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_register_finalizer)"></a><a name="(idx._(gentag._277._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_register_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_finalizer</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">data</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">oldf</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void**</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">olddata</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Registers a callback function to be invoked when the memory <span style="font-family: 楷体">p</span>
would otherwise be garbage-collected, and when no &ldquo;will&rdquo;-like
finalizers are registered for <span style="font-family: 楷体">p</span>.</div></p><p>The <span class="stt">fnl_proc</span> type is not actually defined, but it is equivalent
to</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">typedef void (*fnl_proc)(void *p, void *data)</span></p></td></tr></table></p><p>The <span style="font-family: 楷体">f</span> argument is the callback function; when it is called, it
will be passed the value <span style="font-family: 楷体">p</span> and the data pointer <span style="font-family: 楷体">data</span>;
<span style="font-family: 楷体">data</span> can be anything &#8212;<wbr></wbr> it is only passed on to the callback
function. If <span style="font-family: 楷体">oldf</span> and <span style="font-family: 楷体">olddata</span> are not <span class="stt">NULL</span>, then
<span style="font-family: 楷体">*oldf</span> and <span style="font-family: 楷体">*olddata</span> are filled with the old callback
information (<span style="font-family: 楷体">f</span> and <span style="font-family: 楷体">data</span> will override this old callback).</p><p>To remove a registered finalizer, pass <span class="stt">NULL</span> for <span style="font-family: 楷体">f</span> and
<span style="font-family: 楷体">data</span>.</p><p>Note: registering a callback not only keeps <span style="font-family: 楷体">p</span> from collection
until the callback is invoked, but it also keeps <span style="font-family: 楷体">data</span> reachable
until the callback is invoked.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_finalizer)"></a><a name="(idx._(gentag._278._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_add_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_finalizer</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Adds a finalizer to a chain of primitive finalizers. This chain is
separate from the single finalizer installed with
<a href="#%28cpp._scheme_register_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_finalizer</span></a>; all finalizers in the chain are
called immediately after a finalizer that is installed with
<a href="#%28cpp._scheme_register_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_finalizer</span></a>.</div></p><p>See <a href="#%28cpp._scheme_register_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_finalizer</span></a>, above, for information about
the arguments.</p><p>To remove an added finalizer, use <a href="#%28cpp._scheme_subtract_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_subtract_finalizer</span></a>.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_scheme_finalizer)"></a><a name="(idx._(gentag._279._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_add_scheme_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_scheme_finalizer</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Installs a &ldquo;will&rdquo;-like finalizer, similar to <span class="RktSym"><a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=willexecutor.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._will-register%2529%2529&amp;version=7.0.0.18" class="RktValLink Sq" data-pltdoc="x">will-register</a></span>.
 Will-like finalizers are called one at a time, requiring the collector
 to prove that a value has become inaccessible again before calling
 the next will-like finalizer. Finalizers registered with
 <a href="#%28cpp._scheme_register_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_finalizer</span></a> or <a href="#%28cpp._scheme_add_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_finalizer</span></a> are
 not called until all will-like finalizers have been exhausted.</div></p><p>See <a href="#%28cpp._scheme_register_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_finalizer</span></a>, above, for information about
 the arguments.</p><p>There is currently no facility to remove a will-like finalizer.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_finalizer_once)"></a><a name="(idx._(gentag._280._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_add_finalizer_once%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_finalizer_once</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#%28cpp._scheme_add_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_finalizer</span></a>, but if the combination <span style="font-family: 楷体">f</span> and
 <span style="font-family: 楷体">data</span> is already registered as a (non-&ldquo;will&rdquo;-like) finalizer
 for <span style="font-family: 楷体">p</span>, it is not added a second time.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_scheme_finalizer_once)"></a><a name="(idx._(gentag._281._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_add_scheme_finalizer_once%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_scheme_finalizer_once</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#%28cpp._scheme_add_scheme_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_scheme_finalizer</span></a>, but if the combination of
 <span style="font-family: 楷体">f</span> and <span style="font-family: 楷体">data</span> is already registered as a &ldquo;will&rdquo;-like
 finalizer for <span style="font-family: 楷体">p</span>, it is not added a second time.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_subtract_finalizer)"></a><a name="(idx._(gentag._282._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_subtract_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_subtract_finalizer</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">fnl_proc</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">data</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Removes a finalizer that was installed with
 <a href="#%28cpp._scheme_add_finalizer%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_finalizer</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_remove_all_finalization)"></a><a name="(idx._(gentag._283._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_remove_all_finalization%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_remove_all_finalization</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Removes all finalization (&ldquo;will&rdquo;-like or not) for <span style="font-family: 楷体">p</span>, including
 wills added in Scheme with <span class="RktSym"><a href="http://docs.racket-lang.org/local-redirect/index.html?doc=reference&amp;rel=willexecutor.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._will-register%2529%2529&amp;version=7.0.0.18" class="RktValLink Sq" data-pltdoc="x">will-register</a></span> and finalizers used
 by custodians.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_dont_gc_ptr)"></a><a name="(idx._(gentag._284._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_dont_gc_ptr%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_dont_gc_ptr</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Keeps the collectable block <span style="font-family: 楷体">p</span> from garbage collection. Use this
 procedure when a reference to <span style="font-family: 楷体">p</span> is be stored somewhere
 inaccessible to the collector. Once the reference is no longer used
 from the inaccessible region, de-register the lock with
 <a href="#%28cpp._scheme_gc_ptr_ok%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_gc_ptr_ok</span></a>. A garbage collection can occur during the
 registration.</div></p><p>This function keeps a reference count on the pointers it registers, so
 two calls to <a href="#%28cpp._scheme_dont_gc_ptr%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_dont_gc_ptr</span></a> for the same <span style="font-family: 楷体">p</span> should
 be balanced with two calls to <a href="#%28cpp._scheme_gc_ptr_ok%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_gc_ptr_ok</span></a>.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_gc_ptr_ok)"></a><a name="(idx._(gentag._285._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_gc_ptr_ok%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_gc_ptr_ok</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">See <a href="#%28cpp._scheme_dont_gc_ptr%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_dont_gc_ptr</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_collect_garbage)"></a><a name="(idx._(gentag._286._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_collect_garbage%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_collect_garbage</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Forces an immediate garbage-collection.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_enable_garbage_collection)"></a><a name="(idx._(gentag._287._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_enable_garbage_collection%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_enable_garbage_collection</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">on</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Garbage collection is enabled only when an internal counter is
<span class="stt">0</span>.  Calling <a href="#%28cpp._scheme_enable_garbage_collection%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_enable_garbage_collection</span></a> with a false
value increments the counter, and calling
<a href="#%28cpp._scheme_enable_garbage_collection%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_enable_garbage_collection</span></a> with a true value decrements
the counter.</div></p><p>When the <span class="stt">PLTDISABLEGC</span> environment variable is set, then
<span class="stt">racket</span> initializes the internal counter to <span class="stt">1</span> to initially
disable garbage collection.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._.G.C_register_traversers)"></a><a name="(idx._(gentag._288._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.G.C_register_traversers%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_register_traversers</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">short</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">tag</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Size_Proc</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">s</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Mark_Proc</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">m</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Fixup_Proc</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">f</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">is_const_size</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">int</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">is_atomic</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">3m only. Registers a size, mark, and fixup procedure for a given type
 tag; see <a href="#%28part._im~3a3m~3atagged%29" data-pltdoc="x">Tagged Objects</a> for more information.</div></p><p>Each of the three procedures takes a pointer and returns an integer:</p><p><table cellspacing="0" cellpadding="0"><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">typedef int (*Size_Proc)(void *obj);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">typedef int (*Mark_Proc)(void *obj);</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;&nbsp;</span><span class="stt">typedef int (*Fixup_Proc)(void *obj);</span></p></td></tr></table></p><p>If the result of the size procedure is a constant, then pass a
 non-zero value for <span style="font-family: 楷体">is_const_size</span>. If the mark and fixup
 procedures are no-ops, then pass a non-zero value
 for <span style="font-family: 楷体">is_atomic</span>.</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._.G.C_resolve)"></a><a name="(idx._(gentag._289._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.G.C_resolve%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_resolve</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">3m only. Can be called by a size, mark, or fixup procedure that is registered
with <a href="#%28cpp._.G.C_register_traversers%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_register_traversers</span></a>. It returns the current address of
an object <span style="font-family: 楷体">p</span> that might have been moved already. This translation is necessary, for
example, if the size or structure of an object depends on the content
of an object it references. For example, the size of a class instance
usually depends on a field count that is stored in the class. A fixup
procedure should call this function on a reference <span style="font-family: 楷体">before</span>
fixing it.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._.G.C_fixup_self)"></a><a name="(idx._(gentag._290._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.G.C_fixup_self%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_fixup_self</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">void*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">p</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">3m only. Can be called by a fixup procedure that is registered with
<a href="#%28cpp._.G.C_register_traversers%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_register_traversers</span></a>. It returns the final address of <span style="font-family: 楷体">p</span>,
which must be the pointer passed to the fixup procedure. The
<a href="#%28cpp._.G.C_resolve%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_resolve</span></a> function would produce the same result, but
<a href="#%28cpp._.G.C_fixup_self%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_fixup_self</span></a> may be more efficient. For some
implementations of the memory manager, the result is the same as
<span style="font-family: 楷体">p</span>, either because objects are not moved or because the object is
moved before it is fixed. With other implementations, an object might
be moved after the fixup process, and the result is the location that
the object will have after garbage collection finished.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_register_type_gc_shape)"></a><a name="(idx._(gentag._291._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_register_type_gc_shape%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_type_gc_shape</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">short</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">type</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">intptr_t*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">shape</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">Like <a href="#%28cpp._.G.C_register_traversers%29" class="RktStxLink" data-pltdoc="x"><span class="stt">GC_register_traversers</span></a>, but using a set of predefined
functions that interpret <span style="font-family: 楷体">shape</span> to traverse a value. The
<span style="font-family: 楷体">shape</span> array is a sequence of commands terminated with
<a href="#%28cpp._.S.C.H.E.M.E_.G.C_.S.H.A.P.E_.T.E.R.M%29" class="RktStxLink" data-pltdoc="x"><span class="stt">SCHEME_GC_SHAPE_TERM</span></a>, where each command has a single argument.</div></p><p>Commands:</p><ul><li><p><span class="stt">#define </span><a name="(cpp._.S.C.H.E.M.E_.G.C_.S.H.A.P.E_.T.E.R.M)"></a><a name="(idx._(gentag._292._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.S.C.H.E.M.E_.G.C_.S.H.A.P.E_.T.E.R.M%29" class="RktStxLink" data-pltdoc="x"><span class="stt">SCHEME_GC_SHAPE_TERM</span></a><span class="stt"> 0</span> &#8212;<wbr></wbr> the terminator
command, which has no argument.</p></li><li><p><span class="stt">#define </span><a name="(cpp._.S.C.H.E.M.E_.G.C_.S.H.A.P.E_.P.T.R_.O.F.F.S.E.T)"></a><a name="(idx._(gentag._293._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.S.C.H.E.M.E_.G.C_.S.H.A.P.E_.P.T.R_.O.F.F.S.E.T%29" class="RktStxLink" data-pltdoc="x"><span class="stt">SCHEME_GC_SHAPE_PTR_OFFSET</span></a><span class="stt"> 1</span> &#8212;<wbr></wbr>
specifies that a object tagged with <span style="font-family: 楷体">type</span> has a pointer
to be made visible to the garbage collector, where the command
argument is the offset from the beginning of the object.</p></li><li><p><span class="stt">#define </span><a name="(cpp._.S.C.H.E.M.E_.G.C_.S.H.A.P.E_.A.D.D_.S.I.Z.E)"></a><a name="(idx._(gentag._294._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._.S.C.H.E.M.E_.G.C_.S.H.A.P.E_.A.D.D_.S.I.Z.E%29" class="RktStxLink" data-pltdoc="x"><span class="stt">SCHEME_GC_SHAPE_ADD_SIZE</span></a><span class="stt"> 2</span> &#8212;<wbr></wbr> specifies
the allocated size of an object tagged with <span style="font-family: 楷体">type</span>,
where the command argument is an amount to add to an
accumulated size; currently, size information is not used, but
it may be needed with future implementations of the garbage
collector.</p></li></ul><p>To improve forward compatibility, any other command is assumed to take
a single argument and is ignored.</p><p>A GC-shape registration is place-specific, even though
<a href="im_values_types.html#%28cpp._scheme_make_type%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_make_type</span></a> creates a type tag that spans places. If a
traversal is already installed for <span class="stt">type</span> in the current place,
the old traversal specification is replaced. The
<a href="#%28cpp._scheme_register_type_gc_shape%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_register_type_gc_shape</span></a> function keeps its own copy of the
array <span style="font-family: 楷体">shape</span>, so the array need not be retained.</p><p class="SHistory">&#28155;&#21152;&#20110;6.4.0.10&#29256;&#26412;&#12290;</p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">Scheme_Object*</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_add_gc_callback)"></a><a name="(idx._(gentag._295._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_add_gc_callback%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_gc_callback</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">pre_desc</span><span class="stt">,</span></p></td></tr><tr><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">post_desc</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">The same as <span class="RktSym"><a href="http://docs.racket-lang.org/local-redirect/index.html?doc=foreign&amp;rel=Garbage_Collection_Callbacks.html%23%2528def._%2528%2528lib._ffi%252Funsafe%252Fcollect-callback..rkt%2529._unsafe-add-collect-callbacks%2529%2529&amp;version=7.0.0.18" class="RktValLink Sq" data-pltdoc="x">unsafe-add-collect-callbacks</a></span> from
<a href="http://docs.racket-lang.org/local-redirect/index.html?doc=foreign&amp;rel=Garbage_Collection_Callbacks.html&amp;version=7.0.0.18" class="RktModLink Sq" data-pltdoc="x"><span class="RktSym">ffi/unsafe/collect-callback</span></a>.</div></p><p><div class="SIntrapara"><table cellspacing="0" cellpadding="0" class="boxed"><tr><td><table cellspacing="0" cellpadding="0"><tr><td><p><span class="stt">void</span></p></td><td><p><span class="hspace">&nbsp;</span></p></td><td><p><a name="(cpp._scheme_remove_gc_callback)"></a><a name="(idx._(gentag._296._(lib._scribblings/inside/inside..scrbl)))"></a><a href="#%28cpp._scheme_remove_gc_callback%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_remove_gc_callback</span></a></p></td><td><p><span class="stt">(</span></p></td><td><p><span class="stt">Scheme_Object*</span><span class="hspace">&nbsp;</span><span style="font-family: 楷体">key</span><span class="stt">)</span></p></td></tr></table></td></tr></table></div><div class="SIntrapara">The same as <span class="RktSym"><a href="http://docs.racket-lang.org/local-redirect/index.html?doc=foreign&amp;rel=Garbage_Collection_Callbacks.html%23%2528def._%2528%2528lib._ffi%252Funsafe%252Fcollect-callback..rkt%2529._unsafe-remove-collect-callbacks%2529%2529&amp;version=7.0.0.18" class="RktValLink Sq" data-pltdoc="x">unsafe-remove-collect-callbacks</a></span>, removes
garbage-collection callbacks installed with
<a href="#%28cpp._scheme_add_gc_callback%29" class="RktStxLink" data-pltdoc="x"><span class="stt">scheme_add_gc_callback</span></a>.</div></p><div class="navsetbottom"><span class="navleft"><form class="searchform"><input class="searchbox" style="color: #888;" type="text" value="…搜索手册…" title="输入搜索字符串以搜索手册" onkeypress="return DoSearchKey(event, this, &quot;7.0.0.18&quot;, &quot;../&quot;);" onfocus="this.style.color=&quot;black&quot;; this.style.textAlign=&quot;left&quot;; if (this.value == &quot;…搜索手册…&quot;) this.value=&quot;&quot;;" onblur="if (this.value.match(/^ *$/)) { this.style.color=&quot;#888&quot;; this.style.textAlign=&quot;center&quot;; this.value=&quot;…搜索手册…&quot;; }"/></form>&nbsp;&nbsp;<a href="../index.html" title="上至文档的顶层" data-pltdoc="x" onclick="return GotoPLTRoot(&quot;7.0.0.18&quot;);">&#39030;&#23618;</a></span><span class="navright">&nbsp;&nbsp;<a href="im_values_types.html" title="后退至&quot;4 Values and Types&quot;" data-pltdoc="x">&larr; &#21069;&#19968;&#39029;</a>&nbsp;&nbsp;<a href="index.html" title="上至&quot;Inside: Racket C API&quot;" data-pltdoc="x">&#19978;&#19968;&#23618;</a>&nbsp;&nbsp;<a href="im_env.html" title="前进至&quot;6 Namespaces and Modules&quot;" data-pltdoc="x">&#21518;&#19968;&#39029; &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>