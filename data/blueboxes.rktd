12342
((3) 0 () 12 ((q lib "data/splay-tree.rkt") (q lib "data/order.rkt") (q lib "data/skip-list.rkt") (q lib "data/enumerate.rkt") (q lib "data/enumerate/lib.rkt") (q lib "data/gvector.rkt") (q lib "data/queue.rkt") (q lib "data/integer-set.rkt") (q lib "data/interval-map.rkt") (q lib "data/bit-vector.rkt") (q lib "data/heap.rkt") (q lib "data/union-find.rkt")) () (h ! (equal) ((c def c (c (? . 0) q splay-tree-remove!)) q (5167 . 4)) ((c def c (c (? . 0) q make-adjustable-splay-tree)) q (4547 . 6)) ((c def c (c (? . 3) q one-way-enum?)) q (18829 . 3)) ((c def c (c (? . 8) q interval-map-update*!)) q (11455 . 11)) ((c def c (c (? . 2) q skip-list-iterate-greatest/<?)) q (9331 . 6)) ((c def c (c (? . 6) q enqueue!)) q (32 . 4)) ((c def c (c (? . 1) q ordered-dict?)) q (2532 . 3)) ((c def c (c (? . 7) q foldr)) q (16137 . 5)) ((c def c (c (? . 1) q order-comparator)) q (3862 . 3)) ((c def c (c (? . 0) q splay-tree-set!)) q (5056 . 5)) ((c def c (c (? . 2) q skip-list-iterate-greatest/<=?)) q (9508 . 6)) ((c def c (c (? . 5) q gvector-count)) q (1874 . 3)) ((c def c (c (? . 3) q enum->list)) q (19423 . 6)) ((c def c (c (? . 4) q nat+/e)) q (27318 . 3)) ((c def c (c (? . 4) q permutations-of-n/e)) q (27547 . 4)) ((c def c (c (? . 5) q vector->gvector)) q (2015 . 3)) ((c def c (c (? . 6) q queue/c)) q (704 . 2)) ((c def c (c (? . 7) q set-integer-set-contents!)) q (14940 . 4)) ((c def c (c (? . 4) q infinite-sequence/e)) q (27752 . 3)) ((c def c (c (? . 6) q non-empty-queue?)) q (584 . 3)) ((c def c (c (? . 6) q queue?)) q (535 . 3)) ((c def c (c (? . 1) q datum-order)) q (4196 . 2)) ((c def c (c (? . 6) q queue-filter!)) q (233 . 4)) ((c def c (c (? . 2) q skip-list?)) q (7541 . 3)) ((c def c (c (? . 2) q skip-list-contract!)) q (8273 . 5)) ((c def c (c (? . 0) q splay-tree-iterate-least/>=?)) q (6470 . 5)) ((c def c (c (? . 5) q gvector-set!)) q (1441 . 6)) ((c def c (c (? . 9) q in-bit-vector)) q (17492 . 3)) ((c def c (c (? . 4) q random-index)) q (28546 . 3)) ((c def c (c (? . 6) q make-queue)) q (0 . 2)) ((c def c (c (? . 5) q gvector?)) q (944 . 3)) ((c def c (c (? . 4) q flip-dep/e)) q (24056 . 20)) ((c def c (c (? . 4) q permutations/e)) q (27653 . 3)) ((c def c (c (? . 5) q gvector-remove!)) q (1641 . 5)) ((c def c (c (? . 0) q splay-tree-iterate-least)) q (6164 . 3)) ((c def c (c (? . 8) q interval-map-ref)) q (10576 . 7)) ((c def c (c (? . 7) q make-range)) q (15160 . 7)) ((c def c (c (? . 1) q ordering/c)) q (2353 . 2)) ((c def c (c (? . 5) q gvector-insert!)) q (1239 . 6)) ((c def c (c (? . 0) q splay-tree-iterate-value)) q (5662 . 4)) ((c def c (c (? . 4) q listof-n/e)) q (25625 . 6)) ((c def c (c (? . 7) q subtract)) q (15451 . 4)) ((c def c (c (? . 5) q gvector->list)) q (2075 . 3)) ((c def c (c (? . 6) q dequeue!)) q (174 . 3)) ((c def c (c (? . 8) q interval-map-iterate-value)) q (13485 . 5)) ((c def c (c (? . 2) q skip-list-ref)) q (7658 . 5)) ((c def c (c (? . 5) q gvector-add!)) q (1150 . 4)) ((c def c (c (? . 4) q two-way-real/e)) q (29079 . 2)) ((c def c (c (? . 10) q heap-sort!)) q (14659 . 4)) ((c def c (c (? . 9) q bit-vector-ref)) q (16752 . 5)) ((c def c (c (? . 8) q interval-map-cons*!)) q (12632 . 11)) ((c def c (c (? . 4) q non-empty-listof/e)) q (25354 . 8)) ((c def c (c (? . 0) q splay-tree-expand!)) q (6025 . 5)) ((c def c (c (? . 1) q dict-iterate-greatest/<=?)) q (3202 . 5)) ((c def c (c (? . 2) q skip-list-iterate-least/>?)) q (9064 . 5)) ((c def c (c (? . 9) q make-bit-vector)) q (16515 . 4)) ((c def c (c (? . 3) q to-nat)) q (19229 . 6)) ((c def c (c (? . 9) q bit-vector)) q (16628 . 3)) ((c def c (c (? . 4) q slice/e)) q (26373 . 14)) ((c def c (c (? . 7) q member?)) q (15969 . 4)) ((c def c (c (? . 1) q real-order)) q (4170 . 2)) ((c def c (c (? . 7) q integer-set-contents)) q (14862 . 3)) ((c def c (c (? . 9) q bit-vector-popcount)) q (17212 . 3)) ((c def c (c (? . 0) q splay-tree-iterate-greatest)) q (6256 . 3)) ((c def c (c (? . 3) q empty/e)) q (20047 . 2)) ((c def c (c (? . 9) q bit-vector->string)) q (18058 . 3)) ((c def c (c (? . 2) q skip-list-iterate-next)) q (8687 . 5)) ((c def c (c (? . 2) q skip-list-remove!)) q (7945 . 4)) ((c def c (c (? . 2) q skip-list-iterate-least)) q (9687 . 3)) ((c def c (c (? . 10) q heap-remove!)) q (14188 . 5)) ((c def c (c (? . 11) q uf-find)) q (18336 . 3)) ((c def c (c (? . 7) q make-integer-set)) q (14784 . 3)) ((c def c (c (? . 3) q enum-contract)) q (18998 . 3)) ((c def c (c (? . 10) q heap-add!)) q (13915 . 4)) ((c def c (c (? . 1) q order)) q (3338 . 12)) ((c def c (c (? . 5) q gvector-ref)) q (995 . 5)) ((c def c (c (? . 0) q make-splay-tree)) q (4223 . 7)) ((c def c (c (? . 2) q skip-list-iterate-greatest)) q (9793 . 4)) ((c def c (c (? . 3) q flat-enum?)) q (18885 . 3)) ((c def c (c (? . 11) q uf-set-canonical!)) q (18535 . 4)) ((c def c (c (? . 4) q single/e)) q (27011 . 4)) ((c def c (c (? . 0) q splay-tree-iterate-greatest/<=?)) q (6714 . 5)) ((c def c (c (? . 4) q vector/e)) q (27414 . 4)) ((c def c (c (? . 4) q number/e)) q (29296 . 2)) ((c def c (c (? . 0) q splay-tree-ref)) q (4910 . 5)) ((c def c (c (? . 7) q intersect)) q (15362 . 4)) ((c def c (c (? . 1) q dict-iterate-least)) q (2588 . 3)) ((c def c (c (? . 8) q interval-map?)) q (10520 . 3)) ((c def c (c (? . 7) q well-formed-set?)) q (15101 . 3)) ((c def c (c (? . 1) q order?)) q (3813 . 3)) ((c def c (c (? . 5) q in-gvector)) q (2189 . 3)) ((c def c (c (? . 3) q in-enum)) q (19638 . 3)) ((c def c (c (? . 7) q subset?)) q (16432 . 4)) ((c def c (c (? . 9) q bit-vector-copy)) q (17300 . 5)) ((c def c (c (? . 11) q uf-same-set?)) q (18457 . 4)) ((c def c (c (? . 2) q skip-list-count)) q (8046 . 3)) ((c def c (c (? . 3) q two-way-enum?)) q (18773 . 3)) ((c def c (c (? . 0) q adjustable-splay-tree?)) q (4845 . 3)) ((c def c (c (? . 0) q splay-tree-count)) q (5254 . 3)) ((c def c (c (? . 0) q splay-tree-iterate-greatest/<?)) q (6591 . 5)) ((c def c (c (? . 2) q skip-list-iterate-key)) q (8828 . 4)) ((c def c (c (? . 3) q enum-count)) q (18938 . 3)) ((c def c (c (? . 9) q bit-vector-set!)) q (16913 . 6)) ((c def c (c (? . 0) q splay-tree?)) q (4791 . 3)) ((c def c (c (? . 0) q splay-tree-iterate-least/>?)) q (6351 . 4)) ((c def c (c (? . 11) q uf-union!)) q (18385 . 4)) ((c def c (c (? . 3) q thunk/e)) q (21437 . 19)) ((c def c (c (? . 0) q splay-tree-iterate-first)) q (5337 . 3)) ((c def c (c (? . 8) q interval-map-expand!)) q (12395 . 7)) ((c def c (c (? . 1) q gen:ordered-dict)) q (2387 . 2)) ((c def c (c (? . 7) q get-integer)) q (16054 . 3)) ((c def c (c (? . 4) q real/e)) q (29153 . 2)) ((c def c (c (? . 11) q uf-set?)) q (18286 . 3)) ((c def c (c (? . 6) q in-queue)) q (643 . 3)) ((c def c (c (? . 2) q skip-list-remove-range!)) q (8143 . 5)) ((c def c (c (? . 3) q enum?)) q (18613 . 3)) ((c def c (c (? . 8) q make-interval-map)) q (10127 . 9)) ((c def c (c (? . 4) q hash-traverse/e)) q (27826 . 9)) ((c def c (c (? . 10) q heap-add-all!)) q (13988 . 4)) ((c def c (c (? . 1) q order-<?)) q (4094 . 3)) ((c form c (c (? . 4) q delay/e)) q (25764 . 7)) ((c def c (c (? . 6) q nonempty-queue/c)) q (735 . 2)) ((c def c (c (? . 4) q set/e)) q (27707 . 3)) ((c def c (c (? . 7) q partition)) q (16276 . 3)) ((c def c (c (? . 2) q skip-list-expand!)) q (8428 . 5)) ((c def c (c (? . 0) q splay-tree-contract!)) q (5884 . 5)) ((c def c (c (? . 5) q list->gvector)) q (2133 . 3)) ((c def c (c (? . 10) q heap->vector)) q (14433 . 3)) ((c form c (c (? . 9) q for/bit-vector)) q (17557 . 9)) ((c form c (c (? . 4) q cons/de)) q (23588 . 12)) ((c def c (c (? . 4) q fin/e)) q (26933 . 3)) ((c def c (c (? . 1) q order-domain-contract)) q (3948 . 3)) ((c def c (c (? . 5) q gvector->vector)) q (1953 . 3)) ((c def c (c (? . 9) q list->bit-vector)) q (17977 . 3)) ((c def c (c (? . 2) q skip-list-iterate-least/>=?)) q (9197 . 5)) ((c def c (c (? . 8) q interval-map-ref/bounds)) q (10834 . 10)) ((c def c (c (? . 3) q below/e)) q (19758 . 7)) ((c def c (c (? . 4) q symbol/e)) q (28797 . 2)) ((c def c (c (? . 10) q vector->heap)) q (14328 . 4)) ((c def c (c (? . 3) q or/e)) q (21044 . 4)) ((c def c (c (? . 10) q heap-count)) q (13844 . 3)) ((c def c (c (? . 9) q bit-vector->list)) q (17900 . 3)) ((c def c (c (? . 4) q string/e)) q (28665 . 2)) ((c def c (c (? . 2) q skip-list-iter-valid?)) q (9961 . 3)) ((c def c (c (? . 10) q heap-remove-min!)) q (14132 . 3)) ((c def c (c (? . 3) q from-nat)) q (19061 . 6)) ((c def c (c (? . 4) q take/e)) q (26066 . 9)) ((c def c (c (? . 10) q heap-min)) q (14084 . 3)) ((c def c (c (? . 2) q make-adjustable-skip-list)) q (7289 . 6)) ((c def c (c (? . 6) q queue->list)) q (327 . 3)) ((c def c (c (? . 9) q bit-vector-length)) q (17126 . 3)) ((c def c (c (? . 4) q two-way-number/e)) q (29219 . 3)) ((c def c (c (? . 3) q list/e)) q (22457 . 4)) ((c def c (c (? . 10) q heap?)) q (13796 . 3)) ((c def c (c (? . 11) q uf-new)) q (18238 . 3)) ((c def c (c (? . 8) q interval-map-iterate-first)) q (12990 . 4)) ((c def c (c (? . 9) q string->bit-vector)) q (18149 . 3)) ((c def c (c (? . 8) q interval-map-set!)) q (11164 . 9)) ((c def c (c (? . 7) q complement)) q (15737 . 5)) ((c def c (c (? . 2) q skip-list-iter?)) q (9903 . 3)) ((c def c (c (? . 5) q make-gvector)) q (775 . 3)) ((c def c (c (? . 2) q adjustable-skip-list?)) q (7594 . 3)) ((c def c (c (? . 4) q exact-rational/e)) q (29002 . 3)) ((c def c (c (? . 2) q skip-list->list)) q (10041 . 3)) ((c def c (c (? . 3) q pam/e)) q (20653 . 6)) ((c def c (c (? . 0) q splay-tree-iterate-next)) q (5430 . 4)) ((c def c (c (? . 2) q skip-list-set!)) q (7820 . 5)) ((c def c (c (? . 3) q dep/e)) q (22588 . 20)) ((c def c (c (? . 0) q splay-tree-iterate-key)) q (5558 . 4)) ((c def c (c (? . 0) q splay-tree-iter?)) q (6838 . 3)) ((c def c (c (? . 2) q make-skip-list)) q (6969 . 7)) ((c def c (c (? . 4) q bool/e)) q (28733 . 2)) ((c def c (c (? . 8) q interval-map-iter?)) q (13662 . 3)) ((c def c (c (? . 9) q bit-vector?)) q (16698 . 3)) ((c def c (c (? . 8) q interval-map-iterate-next)) q (13112 . 6)) ((c def c (c (? . 8) q interval-map-iterate-key)) q (13310 . 5)) ((c def c (c (? . 3) q finite-enum?)) q (18661 . 3)) ((c def c (c (? . 7) q split)) q (15624 . 4)) ((c def c (c (? . 1) q dict-iterate-greatest)) q (2693 . 4)) ((c def c (c (? . 6) q queue-length)) q (397 . 3)) ((c def c (c (? . 5) q gvector-remove-last!)) q (1809 . 3)) ((c form c (c (? . 9) q for*/bit-vector)) q (17813 . 3)) ((c def c (c (? . 4) q flonum/e)) q (28934 . 2)) ((c def c (c (? . 0) q splay-tree->list)) q (6897 . 3)) ((c def c (c (? . 10) q in-heap)) q (14602 . 3)) ((c def c (c (? . 7) q count)) q (16359 . 3)) ((c def c (c (? . 1) q dict-iterate-least/>=?)) q (2934 . 5)) ((c def c (c (? . 4) q range/e)) q (27128 . 5)) ((c def c (c (? . 4) q cons/e)) q (24950 . 5)) ((c def c (c (? . 7) q symmetric-difference)) q (15869 . 4)) ((c def c (c (? . 8) q interval-map-contract!)) q (12152 . 7)) ((c def c (c (? . 2) q skip-list-iterate-first)) q (8581 . 3)) ((c def c (c (? . 3) q except/e)) q (20887 . 5)) ((c def c (c (? . 7) q integer-set?)) q (15046 . 3)) ((c def c (c (? . 3) q map/e)) q (20112 . 13)) ((c def c (c (? . 4) q integer/e)) q (28865 . 2)) ((c def c (c (? . 5) q gvector)) q (883 . 3)) ((c def c (c (? . 3) q natural/e)) q (19689 . 2)) ((c def c (c (? . 6) q queue-empty?)) q (479 . 3)) ((c def c (c (? . 10) q heap-copy)) q (14487 . 3)) ((c def c (c (? . 10) q in-heap/consume!)) q (14536 . 3)) ((c def c (c (? . 4) q listof/e)) q (25099 . 7)) ((c def c (c (? . 3) q append/e)) q (21217 . 5)) ((c def c (c (? . 4) q fold-enum)) q (28194 . 9)) ((c def c (c (? . 2) q skip-list-iterate-value)) q (8945 . 4)) ((c def c (c (? . 1) q dict-iterate-greatest/<?)) q (3067 . 5)) ((c def c (c (? . 1) q dict-iterate-least/>?)) q (2802 . 5)) ((c def c (c (? . 1) q prop:ordered-dict)) q (2418 . 3)) ((c def c (c (? . 0) q splay-tree-remove-range!)) q (5768 . 5)) ((c def c (c (? . 10) q make-heap)) q (13723 . 3)) ((c def c (c (? . 3) q bounded-list/e)) q (23465 . 5)) ((c form c (c (? . 5) q for*/gvector)) q (2300 . 2)) ((c def c (c (? . 6) q enqueue-front!)) q (100 . 4)) ((c form c (c (? . 5) q for/gvector)) q (2248 . 2)) ((c def c (c (? . 4) q char/e)) q (28601 . 2)) ((c def c (c (? . 8) q interval-map-remove!)) q (11883 . 7)) ((c def c (c (? . 1) q order-=?)) q (4018 . 3)) ((c def c (c (? . 7) q union)) q (15539 . 4)) ((c def c (c (? . 3) q infinite-enum?)) q (18716 . 3))))
函数
(make-queue) -> queue?
函数
(enqueue! q v) -> void?
  q : queue?
  v : any/c
函数
(enqueue-front! q v) -> void?
  q : queue?
  v : any/c
函数
(dequeue! q) -> any/c
  q : non-empty-queue?
函数
(queue-filter! q pred?) -> void?
  q : queue?
  pred? : (-> any/c any/c)
函数
(queue->list queue) -> (listof any/c)
  queue : queue?
函数
(queue-length queue) -> exact-nonnegative-integer?
  queue : queue?
函数
(queue-empty? q) -> boolean?
  q : queue?
函数
(queue? v) -> boolean?
  v : any/c
函数
(non-empty-queue? v) -> boolean?
  v : any/c
函数
(in-queue queue) -> sequence?
  queue : queue?
值
queue/c : flat-contract?
值
nonempty-queue/c : flat-contract?
函数
(make-gvector [#:capacity capacity]) -> gvector?
  capacity : exact-positive-integer? = 10
函数
(gvector elem ...) -> gvector?
  elem : any/c
函数
(gvector? x) -> boolean?
  x : any/c
函数
(gvector-ref gv index [default]) -> any/c
  gv : gvector?
  index : exact-nonnegative-integer?
  default : any/c = (error ....)
函数
(gvector-add! gv value ...) -> void?
  gv : gvector?
  value : any/c
函数
(gvector-insert! gv index value) -> void?
  gv : gvector
  index : (and/c exact-nonnegative-integer?
                 (</c (+ 1 (gvector-count gv))))
  value : any/c
函数
(gvector-set! gv index value) -> void?
  gv : gvector?
  index : (and/c exact-nonnegative-integer?
                 (</c (+ 1 (gvector-count gv))))
  value : any/c
函数
(gvector-remove! gv index) -> void?
  gv : gvector?
  index : (and/c exact-nonnegative-integer?
                 (</c (gvector-count gv)))
函数
(gvector-remove-last! gv) -> any/c
  gv : gvector?
函数
(gvector-count gv) -> exact-nonnegative-integer?
  gv : gvector?
函数
(gvector->vector gv) -> vector?
  gv : gvector?
函数
(vector->gvector v) -> gvector?
  v : vector?
函数
(gvector->list gv) -> list?
  gv : gvector?
函数
(list->gvector l) -> gvector?
  l : list?
函数
(in-gvector gv) -> sequence?
  gv : gvector?
语法
(for/gvector (for-clause ...) body ...+)
语法
(for*/gvector (for-clause ...) body ...+)
值
ordering/c : flat-contract?
值
gen:ordered-dict : any/c
值
prop:ordered-dict : (struct-type-property/c
                     (vectorof e/c e/c s/c s/c s/c s/c))
函数
(ordered-dict? x) -> boolean?
  x : any/c
函数
(dict-iterate-least dict) -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
函数
(dict-iterate-greatest dict)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
函数
(dict-iterate-least/>? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
函数
(dict-iterate-least/>=? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
函数
(dict-iterate-greatest/<? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
函数
(dict-iterate-greatest/<=? dict key)
 -> (or/c (dict-iter-contract dict) #f)
  dict : ordered-dict?
  key : any/c
函数
(order name domain-contract comparator)
 -> (and/c order? procedure?)
  name : symbol?
  domain-contract : contract?
  comparator : (-> any/c any/c ordering/c)
(order name domain-contract =? <? [>?]) -> (and/c order? procedure?)
  name : symbol?
  domain-contract : contract?
  =? : (-> any/c any/c boolean?)
  <? : (-> any/c any/c boolean?)
  >? : (-> any/c any/c boolean?) = (lambda (x y) (<? y x))
函数
(order? x) -> boolean?
  x : any/c
函数
(order-comparator ord) -> (-> any/c any/c ordering/c)
  ord : order?
函数
(order-domain-contract ord) -> contract?
  ord : order?
函数
(order-=? ord) -> (-> any/c any/c boolean?)
  ord : order?
函数
(order-<? ord) -> (-> any/c any/c boolean?)
  ord : order?
值
real-order : order?
值
datum-order : order?
函数
(make-splay-tree [ord                                   
                  #:key-contract key-contract           
                  #:value-contract value-contract]) -> splay-tree?
  ord : order? = datum-order
  key-contract : contract? = any/c
  value-contract : contract? = any/c
函数
(make-adjustable-splay-tree [#:key-contract key-contract       
                             #:value-contract value-contract]) 
 -> splay-tree?
  key-contract : contract? = any/c
  value-contract : contract? = any/c
函数
(splay-tree? x) -> boolean?
  x : any/c
函数
(adjustable-splay-tree? x) -> boolean?
  x : any/c
函数
(splay-tree-ref s key [default]) -> any
  s : splay-tree?
  key : any/c
  default : any/c = (lambda () (error ....))
函数
(splay-tree-set! s key value) -> void?
  s : splay-tree?
  key : any/c
  value : any/c
函数
(splay-tree-remove! s key) -> void?
  s : splay-tree?
  key : any/c
函数
(splay-tree-count s) -> exact-nonnegative-integer?
  s : splay-tree?
函数
(splay-tree-iterate-first s) -> (or/c #f splay-tree-iter?)
  s : splay-tree?
函数
(splay-tree-iterate-next s iter) -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  iter : splay-tree-iter?
函数
(splay-tree-iterate-key s iter) -> any/c
  s : splay-tree?
  iter : splay-tree-iter?
函数
(splay-tree-iterate-value s iter) -> any/c
  s : splay-tree?
  iter : splay-tree-iter?
函数
(splay-tree-remove-range! s from to) -> void?
  s : splay-tree?
  from : any/c
  to : any/c
函数
(splay-tree-contract! s from to) -> void?
  s : adjustable-splay-tree?
  from : exact-integer?
  to : exact-integer?
函数
(splay-tree-expand! s from to) -> void?
  s : adjustable-splay-tree?
  from : exact-integer?
  to : exact-integer?
函数
(splay-tree-iterate-least s) -> (or/c #f splay-tree-iter?)
  s : splay-tree
函数
(splay-tree-iterate-greatest s) -> (or/c #f splay-tree-iter?)
  s : splay-tree
函数
(splay-tree-iterate-least/>? s key) -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
函数
(splay-tree-iterate-least/>=? s key)
 -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
函数
(splay-tree-iterate-greatest/<? s key)
 -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
函数
(splay-tree-iterate-greatest/<=? s key)
 -> (or/c #f splay-tree-iter?)
  s : splay-tree?
  key : any/c
函数
(splay-tree-iter? x) -> boolean?
  x : any/c
函数
(splay-tree->list s) -> (listof pair?)
  s : splay-tree?
函数
(make-skip-list [ord                                   
                 #:key-contract key-contract           
                 #:value-contract value-contract]) -> skip-list?
  ord : order? = datum-order
  key-contract : contract? = any/c
  value-contract : contract? = any/c
函数
(make-adjustable-skip-list [#:key-contract key-contract       
                            #:value-contract value-contract]) 
 -> adjustable-skip-list?
  key-contract : contract? = any/c
  value-contract : contract? = any/c
函数
(skip-list? v) -> boolean?
  v : any/c
函数
(adjustable-skip-list? v) -> boolean?
  v : any/c
函数
(skip-list-ref skip-list key [default]) -> any/c
  skip-list : skip-list?
  key : any/c
  default : any/c = (lambda () (error ....))
函数
(skip-list-set! skip-list key value) -> void?
  skip-list : skip-list?
  key : any/c
  value : any/c
函数
(skip-list-remove! skip-list key) -> void?
  skip-list : skip-list?
  key : any/c
函数
(skip-list-count skip-list) -> exact-nonnegative-integer?
  skip-list : skip-list?
函数
(skip-list-remove-range! skip-list from to) -> void?
  skip-list : skip-list?
  from : any/c
  to : any/c
函数
(skip-list-contract! skip-list from to) -> void?
  skip-list : adjustable-skip-list?
  from : exact-integer?
  to : exact-integer?
函数
(skip-list-expand! skip-list from to) -> void?
  skip-list : adjustable-skip-list?
  from : exact-integer?
  to : exact-integer?
函数
(skip-list-iterate-first skip-list) -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
函数
(skip-list-iterate-next skip-list iter)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  iter : skip-list-iter?
函数
(skip-list-iterate-key skip-list iter) -> any/c
  skip-list : skip-list?
  iter : skip-list-iter?
函数
(skip-list-iterate-value skip-list iter) -> any/c
  skip-list : skip-list?
  iter : skip-list-iter?
函数
(skip-list-iterate-least/>? skip-list key)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
函数
(skip-list-iterate-least/>=? skip-list key)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
函数
(skip-list-iterate-greatest/<? skip-list 
                               key)      
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
函数
(skip-list-iterate-greatest/<=? skip-list 
                                key)      
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
  key : any/c
函数
(skip-list-iterate-least skip-list) -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
函数
(skip-list-iterate-greatest skip-list)
 -> (or/c skip-list-iter? #f)
  skip-list : skip-list?
函数
(skip-list-iter? v) -> boolean?
  v : any/c
函数
(skip-list-iter-valid? iter) -> boolean?
  iter : skip-list-iter?
函数
(skip-list->list skip-list) -> (listof pair?)
  skip-list : skip-list?
函数
(make-interval-map [contents                          
                    #:key-contract key-contract       
                    #:value-contract value-contract]) 
 -> interval-map?
  contents : (listof (cons/c (cons/c exact-integer? exact-integer?) any/c))
           = null
  key-contract : contract? = any/c
  value-contract : contract? = any/c
函数
(interval-map? v) -> boolean?
  v : any/c
函数
(interval-map-ref  interval-map     
                   position         
                  [default])    -> any/c
  interval-map : interval-map?
  position : exact-integer?
  default : any/c = (lambda () (error ....))
函数
(interval-map-ref/bounds  interval-map 
                          position     
                         [default])    
 -> (or/c #f exact-integer?)
    (or/c #f exact-integer?)
    any/c
  interval-map : interval-map?
  position : exact-integer?
  default : any/c = (lambda () (error ....))
函数
(interval-map-set! interval-map     
                   start            
                   end              
                   value)       -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
  value : any/c
函数
(interval-map-update*!  interval-map     
                        start            
                        end              
                        updater          
                       [default])    -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
  updater : (-> any/c any/c)
  default : any/c = (lambda () (error ....))
函数
(interval-map-remove! interval-map     
                      start            
                      end)         -> void?
  interval-map : interval-map?
  start : (or/c exact-integer? -inf.0)
  end : (or/c exact-integer? +inf.0)
函数
(interval-map-contract! interval-map     
                        start            
                        end)         -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
函数
(interval-map-expand! interval-map     
                      start            
                      end)         -> void?
  interval-map : interval-map?
  start : exact-integer?
  end : exact-integer?
函数
(interval-map-cons*!  interval-map     
                      start            
                      end              
                      v                
                     [default])    -> void?
  interval-map : interval-map?
  start : any/c
  end : any/c
  v : any/c
  default : any/c = null
函数
(interval-map-iterate-first interval-map)
 -> (or/c interval-map-iter? #f)
  interval-map : interval-map?
函数
(interval-map-iterate-next interval-map 
                           iter)        
 -> (or/c interval-map-iter? #f)
  interval-map : interval-map?
  iter : interval-map-iter?
函数
(interval-map-iterate-key interval-map     
                          iter)        -> pair?
  interval-map : interval-map?
  iter : interval-map-iter?
函数
(interval-map-iterate-value interval-map     
                            iter)        -> any
  interval-map : interval-map?
  iter : interval-map-iter?
函数
(interval-map-iter? v) -> boolean?
  v : any/c
函数
(make-heap <=?) -> heap?
  <=? : (-> any/c any/c any/c)
函数
(heap? x) -> boolean?
  x : any/c
函数
(heap-count h) -> exact-nonnegative-integer?
  h : heap?
函数
(heap-add! h v ...) -> void?
  h : heap?
  v : any/c
函数
(heap-add-all! h v) -> void?
  h : heap?
  v : (or/c list? vector? heap?)
函数
(heap-min h) -> any/c
  h : heap?
函数
(heap-remove-min! h) -> void?
  h : heap?
函数
(heap-remove! h v [#:same? same?]) -> void?
  h : heap?
  v : any/c
  same? : (-> any/c any/c any/c) = equal?
函数
(vector->heap <=? items) -> heap?
  <=? : (-> any/c any/c any/c)
  items : vector?
函数
(heap->vector h) -> vector?
  h : heap?
函数
(heap-copy h) -> heap?
  h : heap?
函数
(in-heap/consume! heap) -> sequence?
  heap : heap?
函数
(in-heap heap) -> sequence?
  heap : heap?
函数
(heap-sort! v <=?) -> void?
  v : (and/c vector? (not/c immutable?))
  <=? : (-> any/c any/c any/c)
函数
(make-integer-set wfs) -> integer-set?
  wfs : well-formed-set?
函数
(integer-set-contents s) -> well-formed-set?
  s : integer-set?
函数
(set-integer-set-contents! s wfs) -> void?
  s : integer-set?
  wfs : well-formed-set?
函数
(integer-set? v) -> boolean?
  v : any/c
函数
(well-formed-set? v) -> boolean?
  v : any/c
函数
(make-range) -> integer-set?
(make-range elem) -> integer-set?
  elem : exact-integer?
(make-range start end) -> integer-set?
  start : exact-integer?
  end : exact-integer?
函数
(intersect x y) -> integer-set?
  x : integer-set?
  y : integer-set?
函数
(subtract x y) -> integer-set?
  x : integer-set?
  y : integer-set?
函数
(union x y) -> integer-set?
  x : integer-set?
  y : integer-set?
函数
(split x y) -> integer-set? integer-set? integer-set?
  x : integer-set?
  y : integer-set?
函数
(complement s start end) -> integer-set?
  s : integer-set?
  start : exact-integer?
  end : exact-integer?
函数
(symmetric-difference x y) -> integer-set?
  x : integer-set?
  y : integer-set?
函数
(member? k s) -> boolean?
  k : exact-integer?
  s : integer-set?
函数
(get-integer set) -> (or/c exact-integer? #f)
  set : integer-set?
函数
(foldr proc base-v s) -> any/c
  proc : (exact-integer? any/c . -> . any/c)
  base-v : any/c
  s : integer-set?
函数
(partition s) -> (listof integer-set?)
  s : (listof integer-set?)
函数
(count s) -> exact-nonnegative-integer?
  s : integer-set?
函数
(subset? x y) -> boolean?
  x : integer-set?
  y : integer-set?
函数
(make-bit-vector size [fill]) -> bit-vector?
  size : exact-integer?
  fill : boolean? = #f
函数
(bit-vector elem ...) -> bit-vector?
  elem : boolean?
函数
(bit-vector? v) -> boolean?
  v : any/c
函数
(bit-vector-ref bv index [default]) -> any/c
  bv : bit-vector?
  index : exact-nonnegative-integer?
  default : any/c = (error ....)
函数
(bit-vector-set! bv index value) -> void?
  bv : bit-vector?
  index : (and/c exact-nonnegative-integer?
                 (</c (+ 1 (bit-vector-length vv))))
  value : boolean?
函数
(bit-vector-length bv) -> exact-nonnegative-integer?
  bv : bit-vector?
函数
(bit-vector-popcount bv) -> exact-nonnegative-integer?
  bv : bit-vector?
函数
(bit-vector-copy bv [start end]) -> bit-vector?
  bv : bit-vector?
  start : exact-nonnegative-integer? = 0
  end : exact-nonnegative-integer? = (vector-length v)
函数
(in-bit-vector bv) -> sequence?
  bv : bit-vector?
语法
(for/bit-vector maybe-length (for-clause ...)
  body-or-break ... body)
 
maybe-length = 
             | #:length length-expr
             | #:length length-expr #:fill fill-expr
 
  length-expr : exact-nonnegative-integer?
语法
(for*/bit-vector maybe-length (for-clause ...)
  body-or-break ... body)
函数
(bit-vector->list bv) -> (listof boolean?)
  bv : bit-vector?
函数
(list->bit-vector bits) -> bit-vector?
  bits : (listof boolean?)
函数
(bit-vector->string bv) -> (and/c string? #rx"^[01]*$")
  bv : bit-vector?
函数
(string->bit-vector s) -> bit-vector?
  s : (and/c string? #rx"^[01]*$")
函数
(uf-new c) -> uf-set?
  c : any/c
函数
(uf-set? x) -> boolean?
  x : any/c
函数
(uf-find a) -> any/c
  a : uf-set?
函数
(uf-union! a b) -> void?
  a : uf-set?
  b : uf-set?
函数
(uf-same-set? a b) -> boolean?
  a : uf-set?
  b : uf-set?
函数
(uf-set-canonical! a c) -> void?
  a : uf-set?
  c : any/c
函数
(enum? x) -> boolean?
  x : any/c
函数
(finite-enum? v) -> boolean?
  v : any/c
函数
(infinite-enum? v) -> boolean?
  v : any/c
函数
(two-way-enum? v) -> boolean?
  v : any/c
函数
(one-way-enum? v) -> boolean?
  v : any/c
函数
(flat-enum? v) -> boolean?
  v : any/c
函数
(enum-count e) -> natural?
  e : finite-enum?
函数
(enum-contract e) -> natural?
  e : finite-enum?
函数
(from-nat e n) -> (enum-contract e)
  e : enum?
  n : (if (finite-enum? e)
          (integer-in 0 (enum-count e))
          natural?)
函数
(to-nat e x) -> (if (finite-enum? e)
                    (integer-in 0 (enum-count e))
                    natural?)
  e : two-way-enum?
  x : (enum-contract e)
函数
(enum->list e [n]) -> (listof (enum-contract e))
  e : enum?
  n : (if (finite-enum? e)              = (enum-count e)
          (integer-in 0 (enum-count e))
          natural?)
函数
(in-enum e) -> sequence?
  e : enum?
值
natural/e : (and/c infinite-enum? two-way-enum? flat-enum?)
函数
(below/e max) -> (and/c (if (= max +inf.0)
                            finite-enum?
                            infinite-enum?)
                        two-way-enum?
                        flat-enum?)
  max : (or/c natural? +inf.0)
值
empty/e : (and/c finite-enum? two-way-enum? flat-enum?)
函数
(map/e f f-inv #:contract c e) -> enum?
  f : (-> (enum-contract e) c)
  f-inv : (-> c (enum-contract e))
  c : contract?
  e : enum?
(map/e f f-inv #:contract c e ...+) -> enum?
  f : (dynamic->* #:mandatory-domain-contracts (map enum-contract e)
                  #:range-contracts (list c))
  f-inv : (dynamic->* #:mandatory-domain-contracts (list c)
                      #:range-contracts (map enum-contract e))
  c : contract?
  e : enum?
函数
(pam/e f #:contract c e ...+) -> one-way-enum?
  f : (dynamic->* #:mandatory-domain-contracts (map enum-contract e)
                  #:range-contracts (list c))
  c : contract?
  e : enum?
函数
(except/e e [#:contract c] x ...) -> two-way-enum?
  e : two-way-enum?
  c : (or/c #f contract?) = #f
  x : (enum-contract e)
函数
(or/e [#:one-way-enum? one-way-enum?] e-p ...) -> enum?
  one-way-enum? : boolean? = #f
  e-p : (or/c enum? (cons/c enum? (-> any/c boolean?)))
函数
(append/e [#:one-way-enum? one-way-enum?]     
           e-p ...+)                      -> enum?
  one-way-enum? : boolean? = #f
  e-p : (or/c enum? (cons/c enum? (-> any/c boolean?)))
函数
(thunk/e  eth                                  
         [#:count count                        
          #:two-way-enum? is-two-way-enum?     
          #:flat-enum? is-flat-enum?])     -> enum?
  eth : (-> (and/c (if (= count +inf.0)
                       infinite-enum?
                       (and/c finite-enum?
                              (let ([matching-count? (λ (e) (= (enum-count e) count))])
                                matching-count?)))
                   (if is-two-way-enum?
                       two-way-enum?
                       one-way-enum?)
                   (if is-flat-enum?
                       flat-enum?
                       (not/c flat-enum?))))
  count : (or/c +inf.0 natural?) = +inf.0
  is-two-way-enum? : any/c = #t
  is-flat-enum? : any/c = #t
函数
(list/e [#:ordering ordering] e ...) -> enum?
  ordering : (or/c 'diagonal 'square) = 'square
  e : enum?
函数
(dep/e  e                                     
        f                                     
       [#:f-range-finite? f-range-finite?     
        #:flat? flat?                         
        #:one-way? one-way?])             -> enum?
  e : enum?
  f : (-> (enum-contract e)
          (and/c (if f-range-finite?
                     finite-enum?
                     infinite-enum?)
                 (if one-way?
                     one-way-enum?
                     two-way-enum?)
                 (if flat?
                     flat-enum?
                     (not/c flat-enum?))))
  f-range-finite? : boolean? = #f
  flat? : boolean? = #t
  one-way? : boolean? = (one-way-enum? e)
函数
(bounded-list/e k n)
 -> (and/c finite-enum? two-way-enum? flat-enum?)
  k : natural?
  n : natural?
语法
(cons/de [car-id car-enumeration-expr]
         [cdr-id (car-id) cdr-enumeration-expr]
         cons/de-option)
(cons/de [car-id (cdr-id) car-enumeration-expr]
         [cdr-id cdr-enumeration-expr]
         cons/de-option)
 
cons/de-option = 
               | #:dep-expression-finite? expr cons/de-option
               | #:flat? expr cons/de-option
               | #:one-way? expr cons/de-option
函数
(flip-dep/e  e                                      
             f                                      
            [#:f-range-finite? f-range-finite?]     
             #:flat? flat?                          
            [#:one-way? one-way?])              -> enum?
  e : enum?
  f : (-> (enum-contract e)
          (and/c (if f-range-finite?
                     finite-enum?
                     infinite-enum?)
                 (if one-way?
                     one-way-enum?
                     two-way-enum?)
                 (if flat?
                     flat-enum?
                     (not/c flat-enum?))))
  f-range-finite? : boolean? = #f
  flat? : #t
  one-way? : boolean? = (one-way-enum? e)
函数
(cons/e e1 e2 [#:ordering ordering]) -> enum?
  e1 : enum?
  e2 : enum?
  ordering : (or/c 'diagonal 'square) = 'square
函数
(listof/e  e                                           
          [#:simple-recursive? simple-recursive?]) -> enum?
  e : (if simple-recursive?
          enum?
          infinite-enum?)
  simple-recursive? : any/c = #t
函数
(non-empty-listof/e  e                                       
                    [#:simple-recursive? simple-recursive?]) 
 -> enum?
  e : (if simple-recursive?
          enum?
          infinite-enum?)
  simple-recursive? : any/c = #t
函数
(listof-n/e e n) -> enum?
  e : (if simple-recursive?
          enum?
          infinite-enum?)
  n : natural?
语法
(delay/e enum-expression ... keyword-options)
 
keyword-options = 
                | #:count count-expression keyword-options
                | #:two-way-enum? two-way-boolean-expression keyword-options
                | #:flat-enum? flat-boolean-expression keyword-options
函数
(take/e e n #:contract contract) -> finite-enum?
  e : enum?
  n : (if (finite-enum? e)
          (integer-in 0 (enum-count e))
          natural?)
  contract : (λ (x)
               (and ((enum-contract e) x)
                    (< (to-nat e x) n)))
函数
(slice/e e lo hi #:contract contract) -> finite-enum?
  e : enum?
  lo : (and/c (if (finite-enum? e)
                  (integer-in 0 (enum-count e))
                  natural?)
              (<=/c hi))
  hi : (if (finite-enum? e)
           (integer-in 0 (enum-count e))
           natural?)
  contract : (and/c (enum-contract e)
                    (λ (x)
                      (<= lo (to-nat e x))
                      (< (to-nat e x) hi)))
函数
(fin/e x ...) -> (and/c finite-enum? flat-enum?)
  x : any/c
函数
(single/e v #:equal? same?) -> (and/c finite-enum? two-way-enum?)
  v : any/c
  same? : equal?
函数
(range/e lo hi) -> (and/c two-way-enum? flat-enum?)
  lo : (and/c (or/c -inf.0 exact-integer?)
              (<=/c hi))
  hi : (or/c exact-integer? +inf.0)
函数
(nat+/e lo) -> (and/c infinite-enum? two-way-enum? flat-enum?)
  lo : natural?
函数
(vector/e [#:ordering ordering] e ...) -> enum?
  ordering : (or/c 'diagonal 'square) = 'square
  e : enum?
函数
(permutations-of-n/e n)
 -> (and/c finite-enum? two-way-enum? flat-enum?)
  n : natural?
函数
(permutations/e l) -> enum?
  l : list?
函数
(set/e e) -> enum?
  e : enum?
函数
(infinite-sequence/e e) -> one-way-enum?
  e : finite-enum?
函数
(hash-traverse/e f                               
                 xs                              
                 #:get-contract get-contract     
                 #:contract contract)        -> enum?
  f : (-> any/c enum?)
  xs : (hash/c any/c any/c)
  get-contract : (-> any/c contract?)
  contract : contract?
函数
(fold-enum f                                      
           bs                                     
           #:f-range-finite? f-range-finite?) -> enum?
  f : (if f-range-finite?
          (-> list? any/c finite-enum?)
          (-> list? any/c infinite-enum?))
  bs : list?
  f-range-finite? : #f
函数
(random-index e) -> natural?
  e : enum?
值
char/e : (and/c finite-enum? two-way-enum? flat-enum?)
值
string/e : (and/c infinite-enum? two-way-enum? flat-enum?)
值
bool/e : (and/c finite-enum? two-way-enum? flat-enum?)
值
symbol/e : (and/c infinite-enum? two-way-enum? flat-enum?)
值
integer/e : (and/c infinite-enum? two-way-enum? flat-enum?)
值
flonum/e : (and/c infinite-enum? two-way-enum? flat-enum?)
值
exact-rational/e
 : (and/c infinite-enum? one-way-enum? flat-enum?)
值
two-way-real/e : (and/c infinite-enum? two-way-enum? flat-enum?)
值
real/e : (and/c infinite-enum? one-way-enum? flat-enum?)
值
two-way-number/e
 : (and/c infinite-enum? two-way-enum? flat-enum?)
值
number/e : (and/c infinite-enum? one-way-enum? flat-enum?)
